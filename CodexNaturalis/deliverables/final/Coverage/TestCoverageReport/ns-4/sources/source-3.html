


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > ViewGUI</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">it.polimi.ingsw.client.view</a>
</div>

<h1>Coverage Summary for Class: ViewGUI (it.polimi.ingsw.client.view)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ViewGUI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/91)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package it.polimi.ingsw.client.view;
&nbsp;
&nbsp;import it.polimi.ingsw.client.view.gui.SceneManager;
&nbsp;import it.polimi.ingsw.client.view.gui.message.GUIMessages;
&nbsp;import it.polimi.ingsw.messages.connectionState.availableColorsMessage;
&nbsp;import it.polimi.ingsw.messages.connectionState.unavailableNamesMessage;
&nbsp;import it.polimi.ingsw.messages.currentStateMessage;
&nbsp;import it.polimi.ingsw.messages.endGameState.declareWinnerMessage;
&nbsp;import it.polimi.ingsw.messages.playerTurnState.updatePlayerMessage;
&nbsp;import it.polimi.ingsw.messages.responseMessage;
&nbsp;import it.polimi.ingsw.messages.serverOptionState.serverOptionMessage;
&nbsp;import it.polimi.ingsw.model.cards.ObjectiveCard;
&nbsp;import javafx.application.Platform;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Objects;
&nbsp;
&nbsp;/**
&nbsp; * This class represents the gui view of the game.
&nbsp; * It extends the View class and overrides its methods to provide a graphical user interface for the game.
&nbsp; * It uses the SceneManager class to manage the different scenes of the game.
&nbsp; * It uses the GUIMessages class to communicate with the client.
&nbsp; */
&nbsp;public class ViewGUI extends View {
<b class="nc">&nbsp;    private boolean firstTimeCurrent = true;</b>
<b class="nc">&nbsp;    private boolean firstTimeName = true;</b>
&nbsp;    private String state;
&nbsp;    private serverOptionMessage newMessage;
&nbsp;    private String color;
&nbsp;    private ArrayList&lt;String&gt; names;
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Constructor for the ViewGUI class.
&nbsp;     * It initializes a new GUIMessages object.
&nbsp;     */
<b class="nc">&nbsp;    public ViewGUI() {</b>
<b class="nc">&nbsp;        GUIMessages.initialize();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method starts the main view of the game.
&nbsp;     * It clears the message queue and updates the scene to the main view.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean startMain() {
&nbsp;        //to avoid reading unexpected messages
<b class="nc">&nbsp;        GUIMessages.clearQueue();</b>
<b class="nc">&nbsp;        Platform.runLater(SceneManager::MainView);</b>
<b class="nc">&nbsp;        return (boolean) GUIMessages.readToClient();</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * This method is used to ask the user for the IP address of the server they want to connect to.
&nbsp;     *
&nbsp;     * @return The IP address entered by the user.
&nbsp;     */
&nbsp;    public String askIP() {
<b class="nc">&nbsp;        state = &quot;IPState&quot;;</b>
&nbsp;        // Clear the message queue to avoid processing any unexpected messages
<b class="nc">&nbsp;        GUIMessages.clearQueue();</b>
&nbsp;
&nbsp;        // Initialize the IP address
&nbsp;        String ip;
&nbsp;
&nbsp;        // Update the gui scene to allow the user to enter the IP address
<b class="nc">&nbsp;        Platform.runLater(SceneManager::InsertIP);</b>
&nbsp;
&nbsp;        // Read the IP address entered by the user from the client
<b class="nc">&nbsp;        ip = (String) GUIMessages.readToClient();</b>
&nbsp;
&nbsp;        // Return the IP address
<b class="nc">&nbsp;        return ip;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method is used to ask the user whether they want to use a socket or rmi for communication.
&nbsp;     *
&nbsp;     * @return A boolean value representing the user&#39;s choice. True for socket, false for rmi.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean askSocket() {
<b class="nc">&nbsp;        state = &quot;SocketState&quot;;</b>
<b class="nc">&nbsp;        GUIMessages.clearQueue();</b>
&nbsp;        boolean useSocket;
<b class="nc">&nbsp;        Platform.runLater(SceneManager::Choose_Socket_RMI);</b>
<b class="nc">&nbsp;        useSocket = (boolean) GUIMessages.readToClient();</b>
<b class="nc">&nbsp;        return useSocket; // true = socket, false = rmi</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method handles the server options for the user.
&nbsp;     *
&nbsp;     * @param message The server option message to be sent to the gui.
&nbsp;     * @return The server option message received from the client.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public serverOptionMessage serverOptions(serverOptionMessage message) {
<b class="nc">&nbsp;        state = &quot;ServerOptionState&quot;;</b>
<b class="nc">&nbsp;        GUIMessages.clearQueue();</b>
<b class="nc">&nbsp;        GUIMessages.writeToGUI(message);</b>
<b class="nc">&nbsp;        Platform.runLater(SceneManager::InsertServerOption);</b>
<b class="nc">&nbsp;        newMessage = (serverOptionMessage) GUIMessages.readToClient();</b>
<b class="nc">&nbsp;        return newMessage;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method is called when a player disconnects from the game.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void playerDisconnected(Exception e) {
<b class="nc">&nbsp;        state = &quot;DisconnectedState&quot;;</b>
<b class="nc">&nbsp;        GUIMessages.clearQueue();</b>
&nbsp;
&nbsp;        // Sends a message to GamePageController Thread to end its threads
<b class="nc">&nbsp;        GUIMessages.writeToGUI(&quot;disconnected&quot;);</b>
&nbsp;
&nbsp;        // Allows the user to reload correctly the page
<b class="nc">&nbsp;        firstTimeCurrent = true;</b>
<b class="nc">&nbsp;        firstTimeName = true;</b>
&nbsp;
<b class="nc">&nbsp;        if (!Objects.equals(e.getMessage(), &quot;Game ended.&quot;)) {</b>
<b class="nc">&nbsp;            Platform.runLater(SceneManager::disconnect);</b>
&nbsp;            try {
<b class="nc">&nbsp;                Thread.sleep(5000);</b>
<b class="nc">&nbsp;            } catch (InterruptedException ignore) {</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            GUIMessages.readToClient(); //read the click of the ToMain button from the GamePageController</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * This method is used when a user needs to choose a name
&nbsp;     *
&nbsp;     * @param message An instance of unavailableNamesMessage, which contains the list of names that are already taken.
&nbsp;     * @return The new name provided by the user.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String unavailableNames(unavailableNamesMessage message) {
<b class="nc">&nbsp;        state = &quot;UnavailableNamesState&quot;;</b>
<b class="nc">&nbsp;        GUIMessages.clearQueue();  //remove all elements that could be in the queue</b>
&nbsp;
&nbsp;        // Avoids to reload the page if the user entered a wrong name
<b class="nc">&nbsp;        if (firstTimeName) {</b>
<b class="nc">&nbsp;            firstTimeName = false;</b>
<b class="nc">&nbsp;            Platform.runLater(SceneManager::unavailableNames);</b>
&nbsp;        }
<b class="nc">&nbsp;        names = message.getNames();</b>
<b class="nc">&nbsp;        GUIMessages.writeToGUI(message);</b>
<b class="nc">&nbsp;        return (String) GUIMessages.readToClient();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method visualizes the response about the value entered
&nbsp;     *
&nbsp;     * @param message: responseMessage
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean answer(responseMessage message) {
&nbsp;        //to avoid reading unexpected messages
&nbsp;        boolean ok;
<b class="nc">&nbsp;        GUIMessages.clearQueue();</b>
<b class="nc">&nbsp;        if (!message.getCorrect()) {</b>
<b class="nc">&nbsp;            switch (state) {</b>
&nbsp;                case &quot;PlaceTurnState&quot;, &quot;PickTurnState&quot;, &quot;objectiveState&quot;, &quot;StarterCardState&quot;, &quot;endGameState&quot; -&gt; {
<b class="nc">&nbsp;                    GUIMessages.writeToGUI(message);</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;                case &quot;ServerOptionState&quot; -&gt; {
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;                default -&gt; {
<b class="nc">&nbsp;                    Platform.runLater(SceneManager::disconnect);</b>
<b class="nc">&nbsp;                    ok = (boolean) GUIMessages.readToClient();</b>
<b class="nc">&nbsp;                    return ok;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        } else if (message.getCorrect() &amp;&amp; (Objects.equals(state, &quot;NameFAState&quot;) || Objects.equals(state, &quot;AvailableColorsState&quot;))</b>
<b class="nc">&nbsp;                &amp;&amp; !Objects.equals(state, &quot;WaitingState&quot;) &amp;&amp; (!newMessage.isNewMatch() || (newMessage.getMatchID() != null &amp;&amp; !names.isEmpty()))) {</b>
<b class="nc">&nbsp;            GUIMessages.writeToGUI(&quot;random&quot;);</b>
<b class="nc">&nbsp;            Platform.runLater(SceneManager::waiting);</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method allows the user to choose his color
&nbsp;     *
&nbsp;     * @param message: availableColorsMessage, which contains the list of available colors.
&nbsp;     * @return color chosen by the user
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String availableColors(availableColorsMessage message) {
<b class="nc">&nbsp;        state = &quot;AvailableColorsState&quot;;</b>
<b class="nc">&nbsp;        GUIMessages.clearQueue();</b>
<b class="nc">&nbsp;        GUIMessages.writeToGUI(message); //in AvailableColorsController we call GUIMessages.readToGui() to receive this message</b>
<b class="nc">&nbsp;        Platform.runLater(SceneManager::availableColors); //run the method availableColors in SceneManager</b>
<b class="nc">&nbsp;        color = (String) GUIMessages.readToClient(); //read the object we sent calling GUIMessages.writeToClient() in AvailableColorsController</b>
<b class="nc">&nbsp;        return color;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method allows the user to choose how many players will play
&nbsp;     *
&nbsp;     * @return number of expected players
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int expectedPlayers() {
<b class="nc">&nbsp;        state = &quot;ExpectedPlayersState&quot;;</b>
<b class="nc">&nbsp;        GUIMessages.clearQueue();</b>
&nbsp;        int number;
<b class="nc">&nbsp;        Platform.runLater(SceneManager::expectedPlayers); //run the method expectedPlayers in SceneManager</b>
<b class="nc">&nbsp;        number = (int) GUIMessages.readToClient();</b>
&nbsp;
<b class="nc">&nbsp;        return number;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method visualizes the waiting status of the match.
&nbsp;     * The first player to connect to the server is the host and will wait for other players to be ready
&nbsp;     * after choosing the number of players.
&nbsp;     * The other players after choosing name and color will wait for the other players to choose too.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void waiting() {
<b class="nc">&nbsp;        state = &quot;WaitingState&quot;;</b>
<b class="nc">&nbsp;        GUIMessages.clearQueue();</b>
<b class="nc">&nbsp;        GUIMessages.writeToGUI(color);</b>
<b class="nc">&nbsp;        Platform.runLater(SceneManager::waiting);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Method {@code updatePlayer} loads the main page of the game and updates the player&#39;s state
&nbsp;     *
&nbsp;     * @param message: currentStateMessage
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void updatePlayer(currentStateMessage message) {
<b class="nc">&nbsp;        state = message.getStateName();</b>
<b class="nc">&nbsp;        GUIMessages.clearQueue();</b>
<b class="nc">&nbsp;        GUIMessages.writeToGUI(message);</b>
<b class="nc">&nbsp;        if (firstTimeCurrent) {</b>
<b class="nc">&nbsp;            firstTimeCurrent = false; //Load this page only the first time the method is called</b>
<b class="nc">&nbsp;            Platform.runLater(SceneManager::gamePage);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method {@code placeStarter}: Places the starter card
&nbsp;     *
&nbsp;     * @return int: the side of the card
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int placeStarter() {
<b class="nc">&nbsp;        return (int) GUIMessages.readToClient();</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method {@code chooseObjective}: Allows the player to choose an objective card
&nbsp;     *
&nbsp;     * @param objectives: the list of objective cards
&nbsp;     * @return the index of the chosen objective card
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int chooseObjective(ArrayList&lt;ObjectiveCard&gt; objectives) {
<b class="nc">&nbsp;        GUIMessages.writeToGUI(objectives);</b>
<b class="nc">&nbsp;        return (int) GUIMessages.readToClient();</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method {@code placeCard}: Allows the player to place a card
&nbsp;     *
&nbsp;     * @return the index of the chosen card, front or back, and coordinates of the chosen cell
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int[] placeCard() {
<b class="nc">&nbsp;        return (int[]) GUIMessages.readToClient();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method {@code pickCard}: Allows the player to pick a card to draw
&nbsp;     *
&nbsp;     * @return the index of the chosen card
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int pickCard() {
<b class="nc">&nbsp;        return (int) GUIMessages.readToClient();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method {@code update}: Updates the parameters of the player that concluded his turn
&nbsp;     *
&nbsp;     * @param updateMsg: updatePlayerMessage
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void update(updatePlayerMessage updateMsg) {
<b class="nc">&nbsp;        GUIMessages.writeToGUI(updateMsg);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method allows the user to choose a nickname from the list of available names
&nbsp;     *
&nbsp;     * @param message the message containing the list of available names
&nbsp;     * @return the chosen nickname
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String pickNameFA(unavailableNamesMessage message) {
<b class="nc">&nbsp;        state = &quot;NameFAState&quot;;</b>
&nbsp;        //to avoid reading unexpected messages
<b class="nc">&nbsp;        GUIMessages.clearQueue();  //remove all elements that could be in the queue</b>
&nbsp;        String name;
<b class="nc">&nbsp;        GUIMessages.writeToGUI(message);  //serialize the message and send it to the gui</b>
<b class="nc">&nbsp;        Platform.runLater(SceneManager::pickNameFA); //run the method unavailableNames in SceneManager</b>
<b class="nc">&nbsp;        name = (String) GUIMessages.readToClient(); //deserialize the string the method must return</b>
<b class="nc">&nbsp;        return name;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method visualize the final information about the game, the number of objectives achieved by each player and then
&nbsp;     * show the scoreboard with the personal points of the players
&nbsp;     *
&nbsp;     * @param message declareWinnerMessage
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void endGame(declareWinnerMessage message) {
<b class="nc">&nbsp;        state = &quot;endGameState&quot;;</b>
<b class="nc">&nbsp;        GUIMessages.writeToGUI(message);</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-06-26 22:00</div>
</div>
</body>
</html>
