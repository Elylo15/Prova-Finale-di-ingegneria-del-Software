


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > MatchManager</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">it.polimi.ingsw.server</a>
</div>

<h1>Coverage Summary for Class: MatchManager (it.polimi.ingsw.server)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MatchManager</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (27/27)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    61,7%
  </span>
  <span class="absValue">
    (158/256)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75,4%
  </span>
  <span class="absValue">
    (356/472)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MatchManager$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (9/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MatchManager$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MatchManager$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (32/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    61,5%
  </span>
  <span class="absValue">
    (160/260)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75,8%
  </span>
  <span class="absValue">
    (372/491)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package it.polimi.ingsw.server;
&nbsp;
&nbsp;import it.polimi.ingsw.messages.currentStateMessage;
&nbsp;import it.polimi.ingsw.messages.objectiveState.objectiveCardMessage;
&nbsp;import it.polimi.ingsw.messages.playerTurnState.pickCardMessage;
&nbsp;import it.polimi.ingsw.messages.playerTurnState.placeCardMessage;
&nbsp;import it.polimi.ingsw.messages.playerTurnState.updatePlayerMessage;
&nbsp;import it.polimi.ingsw.messages.staterCardState.starterCardMessage;
&nbsp;import it.polimi.ingsw.messages.waitingForPlayerState.expectedPlayersMessage;
&nbsp;import it.polimi.ingsw.model.Match;
&nbsp;import it.polimi.ingsw.model.Player;
&nbsp;import it.polimi.ingsw.model.cards.ObjectiveCard;
&nbsp;import it.polimi.ingsw.model.cards.PlaceableCard;
&nbsp;import it.polimi.ingsw.model.cards.exceptions.InvalidIdException;
&nbsp;import it.polimi.ingsw.model.cards.exceptions.noPlaceCardException;
&nbsp;import it.polimi.ingsw.server.exceptions.FailedToJoinMatch;
&nbsp;import it.polimi.ingsw.server.fsm.MatchState;
&nbsp;import it.polimi.ingsw.server.fsm.State;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.io.FileOutputStream;
&nbsp;import java.io.ObjectOutputStream;
&nbsp;import java.util.*;
&nbsp;import java.util.concurrent.Future;
&nbsp;import java.util.concurrent.LinkedBlockingQueue;
&nbsp;import java.util.concurrent.ThreadPoolExecutor;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;/**
&nbsp; * This class manages the clients connected and the game logic.
&nbsp; * It is responsible for handling the connection of clients, the game flow, and the disconnection of clients.
&nbsp; */
&nbsp;public class MatchManager implements Runnable {
&nbsp;    private final MatchInfo matchInfo;
&nbsp;    private final int timeout;
&nbsp;    private final ThreadPoolExecutor executor;
&nbsp;    private final LogCreator logCreator;
&nbsp;    private int turnNumber;
&nbsp;
&nbsp;    /**
&nbsp;     * Standard constructor for MatchManager
&nbsp;     *
&nbsp;     * @param match: is a MatchInfo object representing the model and data related to the server
&nbsp;     */
<b class="fc">&nbsp;    public MatchManager(MatchInfo match) {</b>
<b class="fc">&nbsp;        this.matchInfo = match;</b>
<b class="fc">&nbsp;        this.matchInfo.setLastTurn(false);</b>
<b class="fc">&nbsp;        this.turnNumber = 0; //initialize to 0 the number of turn played</b>
&nbsp;
<b class="fc">&nbsp;        this.timeout = 120 * 1000;</b>
&nbsp;
<b class="fc">&nbsp;        logCreator = new LogCreator(this.matchInfo.getID().toString());</b>
&nbsp;
&nbsp;
<b class="fc">&nbsp;        int corePoolSize = 15;</b>
<b class="fc">&nbsp;        int maximumPoolSize = 50;</b>
<b class="fc">&nbsp;        long keepAliveTime = 300;</b>
<b class="fc">&nbsp;        TimeUnit unit = TimeUnit.SECONDS;</b>
<b class="fc">&nbsp;        executor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, new LinkedBlockingQueue&lt;&gt;());</b>
&nbsp;
<b class="fc">&nbsp;        logCreator.log(&quot;Client manager started&quot;);</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a player to the list of players in the match
&nbsp;     *
&nbsp;     * @param playerInfo player to be added
&nbsp;     * @throws FailedToJoinMatch if the player cannot join the match
&nbsp;     */
&nbsp;    protected synchronized void addPlayerInfo(PlayerInfo playerInfo) throws FailedToJoinMatch {
&nbsp;        //this method is synchronized, so it is not possible to add simultaneously more than one playerInfo on the same MatchManager object
<b class="pc">&nbsp;        if (playerInfo != null</b>
<b class="pc">&nbsp;                &amp;&amp; matchInfo.getStatus() == MatchState.Waiting</b>
<b class="pc">&nbsp;                &amp;&amp; (matchInfo.getExpectedPlayers() == null || matchInfo.getExpectedPlayers() &gt; matchInfo.getAllPlayersInfo().size())</b>
<b class="pc">&nbsp;                &amp;&amp; matchInfo.getAllPlayersInfo().stream().noneMatch(playerInfo1 -&gt; playerInfo1.getPlayer().getNickname().equalsIgnoreCase(playerInfo.getPlayer().getNickname()))</b>
<b class="pc">&nbsp;                &amp;&amp; matchInfo.getAllPlayersInfo().stream().noneMatch(playerInfo1 -&gt; playerInfo1.getPlayer().getColor().equalsIgnoreCase(playerInfo.getPlayer().getColor()))) {</b>
&nbsp;            //in order to add playerInfo to the MatchInfo attribute of MatchManager the match must be in state waiting, number of expected players must be null or lower than the number of players
&nbsp;            //none of the players already involved in the match has the same name and color of the player to add
<b class="fc">&nbsp;            this.matchInfo.addPlayer(playerInfo);</b>
<b class="fc">&nbsp;            logCreator.log(&quot;Player added: &quot; + playerInfo.getPlayer().getNickname() + &quot; &quot; + playerInfo.getPlayer().getColor());</b>
<b class="fc">&nbsp;            this.notifyAll();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            throw new FailedToJoinMatch(&quot;Player cannot join the match&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Kicks a player out of the match, closing its connection.
&nbsp;     *
&nbsp;     * @param playerInfo player to be kicked
&nbsp;     */
&nbsp;    private void kickPlayer(PlayerInfo playerInfo) {
<b class="fc">&nbsp;        this.matchInfo.setOffline(playerInfo);</b>
<b class="fc">&nbsp;        logCreator.log(&quot;Player kicked: &quot; + playerInfo.getPlayer().getNickname() + &quot; and added to offline players&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a player to the list of online players and removes it from the list of offline players
&nbsp;     *
&nbsp;     * @param nickname nickname of the player to be moved
&nbsp;     */
&nbsp;    protected synchronized void wakeUpPlayer(String nickname, ClientConnection connection) throws FailedToJoinMatch {
&nbsp;
&nbsp;        // Check if the state of the match allows the player to join, throws exception if it is not possible to join
<b class="pc">&nbsp;        if (this.matchInfo.getStatus() == MatchState.Waiting || this.matchInfo.getStatus() == MatchState.KickingPlayers || this.matchInfo.getStatus() == MatchState.Endgame) {</b>
<b class="nc">&nbsp;            throw new FailedToJoinMatch(&quot;Player cannot join the match, match is not in the right state&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Check if the player is in the list of players involved in the match and he is offline
<b class="fc">&nbsp;        PlayerInfo playerInfo = matchInfo.getAllPlayersInfo().stream()</b>
<b class="fc">&nbsp;                .filter(playerInfo1 -&gt; playerInfo1.getPlayer().getNickname().equalsIgnoreCase(nickname))</b>
<b class="pc">&nbsp;                .filter(playerInfo1 -&gt; playerInfo1.getConnection() == null) //if the player is offline his connection has been previously set to null</b>
<b class="fc">&nbsp;                .findFirst().orElse(null);</b>
&nbsp;
&nbsp;
&nbsp;        // Eventually sets up a new connection for the player
<b class="pc">&nbsp;        if (playerInfo != null &amp;&amp; playerInfo.getConnection() == null) {</b>
<b class="fc">&nbsp;            matchInfo.bringOnline(nickname, connection);</b>
<b class="fc">&nbsp;            this.notifyAll();</b>
<b class="fc">&nbsp;            logCreator.log(&quot;Player moved: &quot; + playerInfo.getPlayer().getNickname() + &quot; from offline to online players&quot;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            logCreator.log(&quot;Player &quot; + nickname + &quot; cannot be brought back online&quot;);</b>
<b class="nc">&nbsp;            throw new FailedToJoinMatch(&quot;Player cannot join the match&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Retrieves a list of all online players in the match.
&nbsp;     * A player is considered online if their connection is not null.
&nbsp;     *
&nbsp;     * @return An ArrayList of PlayerInfo objects containing the online players.
&nbsp;     */
&nbsp;    protected ArrayList&lt;PlayerInfo&gt; getOnlinePlayerInfo() {
<b class="fc">&nbsp;        return this.matchInfo.getAllPlayersInfo().stream()</b>
<b class="fc">&nbsp;                .filter(playerInfo -&gt; playerInfo.getConnection() != null)</b>
<b class="fc">&nbsp;                .collect(Collectors.toCollection(ArrayList::new));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Retrieves a list of all online players in the match.
&nbsp;     * @return An ArrayList of PlayerInfo objects containing the offline players.
&nbsp;     */
&nbsp;
&nbsp;    protected ArrayList&lt;PlayerInfo&gt; getOfflinePlayerInfo() {
<b class="fc">&nbsp;        return this.matchInfo.getAllPlayersInfo().stream()</b>
<b class="fc">&nbsp;                .filter(playerInfo -&gt; playerInfo.getConnection() == null)</b>
<b class="fc">&nbsp;                .collect(Collectors.toCollection(ArrayList::new));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Getter of MathInfo
&nbsp;     *
&nbsp;     * @return MatchInfo
&nbsp;     */
&nbsp;    protected MatchInfo getMatchInfo() {
<b class="fc">&nbsp;        return this.matchInfo;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Getter of the Match object (belonging to model)
&nbsp;     *
&nbsp;     * @return the Match attribute of matchInfo
&nbsp;     */
&nbsp;    protected Match getMatch() {
<b class="fc">&nbsp;        return this.matchInfo.getMatch();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * create a clone of matchInfo and write it to a file that is created in the directory &#39;savedMatches&#39;
&nbsp;     */
&nbsp;    private synchronized void saveMatch() {
<b class="fc">&nbsp;        MatchInfo copy = matchInfo.cloneForSerialization(); //obtain an object MatchInfo equal to matchInfo attribute</b>
<b class="fc">&nbsp;        File dir = new File(&quot;savedMatches&quot;);</b>
<b class="pc">&nbsp;        if (!dir.exists()) {</b>
<b class="nc">&nbsp;            boolean dirCreated = dir.mkdir(); //create the file if it does not already exist</b>
&nbsp;
<b class="nc">&nbsp;            if (!dirCreated) {</b>
<b class="nc">&nbsp;                System.out.println(&quot;Failed to create directory to save the match: &quot; + dir.getAbsolutePath()); //standard output stream</b>
<b class="nc">&nbsp;                System.err.println(&quot;Failed to create directory to save the match: &quot; + dir.getAbsolutePath()); //error output stream</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        String filename = &quot;savedMatches/match_&quot; + copy.getID() + &quot;.match&quot;;</b>
<b class="fc">&nbsp;        try (FileOutputStream fileOut = new FileOutputStream(filename); //creates a file with path filename and a FileOutputStream to write bytes to it</b>
<b class="fc">&nbsp;             ObjectOutputStream out = new ObjectOutputStream(fileOut))  //create a ObjectOutputStream to write serialized object to fileOut</b>
&nbsp;        {    //fileOut and out are automatically closed after try block
<b class="fc">&nbsp;            out.writeObject(copy); //write the matchInfo clone to the file</b>
<b class="fc">&nbsp;            logCreator.log(&quot;Match &quot; + copy.getID() + &quot; saved&quot;);</b>
<b class="fc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            e.printStackTrace();</b>
<b class="nc">&nbsp;            logCreator.log(&quot;Failed to save match &quot; + e.getMessage());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Hosts a session for the current game
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void run() {
<b class="fc">&nbsp;        boolean gameOver = false;</b>
<b class="fc">&nbsp;        while (!gameOver) {</b>
&nbsp;
&nbsp;            // After the first turns prioritizes the players who reconnect and are in state StarterCard or Objective
<b class="fc">&nbsp;            synchronized (this) {</b>
&nbsp;                // Draws common objective cards, if the array of common objectives in the match is null call Match method drawCommonObjective()
<b class="fc">&nbsp;                if (this.turnNumber == 2 &amp;&amp; this.matchInfo.getMatch().getCommonObjective()[0] == null) {</b>
<b class="fc">&nbsp;                    this.matchInfo.getMatch().drawCommonObjective();</b>
<b class="fc">&nbsp;                    this.saveMatch();</b>
&nbsp;                }
&nbsp;
&nbsp;                // Checks if there are online player in the StarterCard state after turnNumber 1 in which players place starter card
<b class="fc">&nbsp;                if (this.turnNumber &gt; 1) {</b>
<b class="fc">&nbsp;                    this.getOnlinePlayerInfo().stream()</b>
<b class="pc">&nbsp;                            .filter(playerInfo -&gt; playerInfo.getState() == State.StarterCard)</b>
&nbsp;                            //now stream contains only playerInfo objects whose player is online and in state StarterCard
<b class="fc">&nbsp;                            .forEach(playerInfo -&gt; this.player(playerInfo.getPlayer()));</b>
&nbsp;                }
&nbsp;
&nbsp;
&nbsp;                // Checks if there are online player in the Objective state after turnNumber 2 in which players choose private objective
<b class="fc">&nbsp;                if (this.turnNumber &gt; 2) {</b>
<b class="fc">&nbsp;                    this.getOnlinePlayerInfo().stream()</b>
<b class="pc">&nbsp;                            .filter(playerInfo -&gt; playerInfo.getState() == State.Objective)</b>
<b class="fc">&nbsp;                            .forEach(playerInfo -&gt; this.player(playerInfo.getPlayer()));</b>
&nbsp;                }
&nbsp;
&nbsp;
&nbsp;                // Eventually, if the match is in last turn, we update all players in turn state PlaceCard to LastTurn
<b class="pc">&nbsp;                if (this.matchInfo.isLastTurn()) {</b>
<b class="nc">&nbsp;                    this.getOnlinePlayerInfo().stream()</b>
<b class="nc">&nbsp;                            .filter(playerInfo -&gt; playerInfo.getState() == State.PlaceCard)</b>
<b class="nc">&nbsp;                            .forEach(playerInfo -&gt; playerInfo.setState(State.LastTurn));</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            this.checkPlayersConnections();</b>
&nbsp;
&nbsp;            // Starts the normal flow of the game, we call the methods of this class according to the state of the match
<b class="pc">&nbsp;            switch (this.matchInfo.getStatus()) {</b>
&nbsp;                // enters the case corresponding to match status and then proceeds entering following cases (there is no break)
<b class="fc">&nbsp;                case Waiting -&gt; this.waiting();</b>
&nbsp;                //turn if first player
&nbsp;                case Player1 -&gt; {
&nbsp;                    Player currentPlayer;
<b class="pc">&nbsp;                    if (matchInfo.getMatch().getPlayers().isEmpty())</b>
<b class="nc">&nbsp;                        currentPlayer = null;</b>
&nbsp;                    else
<b class="fc">&nbsp;                        currentPlayer = matchInfo.getMatch().getPlayers().getFirst();</b>
&nbsp;
<b class="fc">&nbsp;                    this.player(currentPlayer);</b>
&nbsp;                } //turn of second player
&nbsp;                case Player2 -&gt; {
&nbsp;                    Player currentPlayer;
<b class="pc">&nbsp;                    if (matchInfo.getMatch().getPlayers().size() &lt; 2)</b>
<b class="nc">&nbsp;                        currentPlayer = null;</b>
&nbsp;                    else
<b class="fc">&nbsp;                        currentPlayer = matchInfo.getMatch().getPlayers().get(1);</b>
&nbsp;
<b class="fc">&nbsp;                    this.player(currentPlayer);</b>
&nbsp;                } //turn of third player
&nbsp;                case Player3 -&gt; {
&nbsp;                    Player currentPlayer;
<b class="pc">&nbsp;                    if (matchInfo.getMatch().getPlayers().size() &lt; 3)</b>
<b class="fc">&nbsp;                        currentPlayer = null; //third player is null if the size of the ArrayList of players is 0 or 1 or 2</b>
&nbsp;                    else  //else he is the player at index 2
<b class="nc">&nbsp;                        currentPlayer = matchInfo.getMatch().getPlayers().get(2);</b>
&nbsp;
<b class="fc">&nbsp;                    this.player(currentPlayer);</b>
&nbsp;                }
&nbsp;                case Player4 -&gt; {
&nbsp;                    Player currentPlayer;
<b class="pc">&nbsp;                    if (matchInfo.getMatch().getPlayers().size() &lt; 4)</b>
<b class="fc">&nbsp;                        currentPlayer = null;</b>
&nbsp;                    else
<b class="nc">&nbsp;                        currentPlayer = matchInfo.getMatch().getPlayers().get(3);</b>
&nbsp;
<b class="fc">&nbsp;                    this.player(currentPlayer);</b>
&nbsp;
<b class="fc">&nbsp;                    this.turnNumber += 1; //increment the number of turns played after every cycle of players playing their turn</b>
&nbsp;
&nbsp;                    //state of the match is actually Player4 only if fourth player is not null and in turn state PickCard
<b class="pc">&nbsp;                    if (currentPlayer != null &amp;&amp; findPlayer(currentPlayer) != null &amp;&amp; findPlayer(currentPlayer).getState() == State.PickCard) {</b>
<b class="nc">&nbsp;                        this.matchInfo.setStatus(MatchState.Player4);</b>
&nbsp;                    }
&nbsp;
<b class="pc">&nbsp;                    if (this.matchInfo.isLastTurn())</b>
<b class="nc">&nbsp;                        this.matchInfo.setStatus(MatchState.Endgame);</b>
&nbsp;
&nbsp;                    //if there is no fourth player and one of the players has achieved at least 20 points or
&nbsp;                    //there is no fourth player and both decks of resource card and gold card have run out of cards
&nbsp;                    // we set lastTurn to true
<b class="pc">&nbsp;                    if (currentPlayer == null || findPlayer(currentPlayer) == null) {</b>
<b class="fc">&nbsp;                        if (this.matchInfo.getMatch().getPlayers().stream()</b>
<b class="pc">&nbsp;                                .anyMatch(player -&gt; player.getScore() &gt;= 20) ||</b>
<b class="pc">&nbsp;                                ( this.getMatch().getCommonArea().getD1().getList().isEmpty()</b>
<b class="nc">&nbsp;                                        &amp;&amp; this.getMatch().getCommonArea().getD2().getList().isEmpty())) {</b>
<b class="nc">&nbsp;                            logCreator.log(&quot;This is the last turn&quot;);</b>
<b class="nc">&nbsp;                            matchInfo.setLastTurn(true);</b>
&nbsp;                        }
&nbsp;                    } else
&nbsp;                    {  //if there are four players and the fourth player is not in state PickCard
&nbsp;                        //and one of the players has achieved at least 20 points or both resource ang gold cards decks have run out of cards
&nbsp;                        //we set lastTurn to true
<b class="nc">&nbsp;                        if (findPlayer(currentPlayer).getState() != State.PickCard) {</b>
<b class="nc">&nbsp;                            if (this.matchInfo.getMatch().getPlayers().stream()</b>
<b class="nc">&nbsp;                                    .anyMatch(player -&gt; player.getScore() &gt;= 20) ||</b>
<b class="nc">&nbsp;                                    ( this.getMatch().getCommonArea().getD1().getList().isEmpty()</b>
<b class="nc">&nbsp;                                            &amp;&amp; this.getMatch().getCommonArea().getD2().getList().isEmpty())) {</b>
<b class="nc">&nbsp;                                logCreator.log(&quot;This is the last turn&quot;);</b>
<b class="nc">&nbsp;                                matchInfo.setLastTurn(true);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;
&nbsp;                }
<b class="fc">&nbsp;                case Endgame -&gt; this.endgame();</b>
&nbsp;
&nbsp;                case KickingPlayers -&gt; {
<b class="fc">&nbsp;                    this.kickingPlayers();</b>
<b class="fc">&nbsp;                    gameOver = true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;            //after each turn we check the connection of each player and the number of online players
<b class="fc">&nbsp;            this.checkPlayersConnections();</b>
<b class="fc">&nbsp;            this.checkOnlinePlayersNumber();</b>
&nbsp;
&nbsp;            // Leaves a pause between each turn in order to allow new clients to join,
&nbsp;            // each iteration of while cycle is performed after half a second from the previous one
&nbsp;            try {
<b class="fc">&nbsp;                Thread.sleep(500);</b>
<b class="nc">&nbsp;            } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;                logCreator.log(&quot;Thread interrupted, while sleeping: &quot; + e.getMessage());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;
<b class="fc">&nbsp;        logCreator.close();</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Manages the WaitingForPlayers state for players to join the match.
&nbsp;     * It sends the current state data to all connected players, asks for the number of expected players for this match
&nbsp;     * and waits for the expected number of players to join.
&nbsp;     * When the number of expected players is met, it adds them to the match (model).
&nbsp;     * If a player takes too long to respond or provides an invalid response, he is kicked from the match.
&nbsp;     */
&nbsp;    private void waiting() {
<b class="fc">&nbsp;        logCreator.log(&quot;Waiting for players&quot;);</b>
&nbsp;
&nbsp;        // Obtains the number of expected players for this match
<b class="fc">&nbsp;        while (this.matchInfo.getExpectedPlayers() == null) {</b>
&nbsp;
<b class="fc">&nbsp;            synchronized (this) {</b>
&nbsp;                // Waiting for the first player to join the match, he will choose the number of players and will be referred as the &quot;host&quot;
<b class="fc">&nbsp;                while (this.getOnlinePlayerInfo().isEmpty()) {</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        this.wait();</b>
<b class="nc">&nbsp;                    } catch (InterruptedException ignore) {</b>
<b class="nc">&nbsp;                        logCreator.log(&quot;Waiting for first player, InterruptedException received and ignored.&quot;);</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            // preventing new player from joining at this moment and not getting all messages correctly
<b class="fc">&nbsp;            synchronized (this) {</b>
&nbsp;
&nbsp;
<b class="fc">&nbsp;                PlayerInfo host = this.getOnlinePlayerInfo().getFirst();</b>
&nbsp;
<b class="pc">&nbsp;                if (host != null) {</b>
&nbsp;                    // Sends current state data to each online player
<b class="fc">&nbsp;                    this.getOnlinePlayerInfo().forEach(playerInfo -&gt; {</b>
<b class="fc">&nbsp;                        currentStateMessage curr = new currentStateMessage(null, playerInfo.getPlayer(), &quot;WaitingForPlayerState&quot;, false, this.onlinePlayersNicknames(), null, this.matchInfo.getID());</b>
<b class="fc">&nbsp;                        playerInfo.getConnection().sendCurrentState(curr); //sends to the client the message</b>
<b class="fc">&nbsp;                        playerInfo.getConnection().sendNewHostMessage(host.getPlayer().getNickname());</b>
&nbsp;                    });
&nbsp;
<b class="fc">&nbsp;                    boolean correctAnswer = false;</b>
<b class="fc">&nbsp;                    while (!correctAnswer) {</b>
&nbsp;                        // If the timer ends the player is kicked
<b class="fc">&nbsp;                        Future&lt;expectedPlayersMessage&gt; future = executor.submit(() -&gt; host.getConnection().getExpectedPlayer());</b>
<b class="fc">&nbsp;                        expectedPlayersMessage expected = null;</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            expected = future.get(this.timeout, TimeUnit.MILLISECONDS); //waits 2 minutes to receive the expectedPlayersMessage response of the host</b>
<b class="nc">&nbsp;                        } catch (Exception e) {</b>
<b class="nc">&nbsp;                            logCreator.log(&quot;Player &quot; + host.getPlayer().getNickname() + &quot; has not answered&quot;);</b>
<b class="nc">&nbsp;                            this.kickPlayer(host); //the host is kicked if his answer is not received</b>
&nbsp;                        }
&nbsp;
<b class="pc">&nbsp;                        if (expected != null) {</b>
&nbsp;                            // Checks if the client has properly given a response
<b class="pc">&nbsp;                            if (expected.isNoResponse()) {</b>
<b class="nc">&nbsp;                                correctAnswer = true;</b>
&nbsp;                                //the host user is kicked if he does not make his choice on time, client will set the noResponse attribute to true on the expectedPlayersMessage forwarded by the controller
<b class="nc">&nbsp;                                this.kickPlayer(host);</b>
&nbsp;                            } else {
&nbsp;                                // Checks if the response is valid and answer back
<b class="pc">&nbsp;                                if (expected.getExpectedPlayers() &gt;= 2 &amp;&amp; expected.getExpectedPlayers() &lt;= 4) {</b>
<b class="fc">&nbsp;                                    this.matchInfo.setExpectedPlayers(expected.getExpectedPlayers());</b>
<b class="fc">&nbsp;                                    correctAnswer = true;</b>
<b class="fc">&nbsp;                                    host.getConnection().sendAnswer(true);</b>
<b class="fc">&nbsp;                                    logCreator.log(&quot;Player &quot; + host.getPlayer().getNickname() + &quot; has correctly answered&quot;);</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    host.getConnection().sendAnswer(false); //send the host a negative responseMessage</b>
&nbsp;                                    //there will be another iteration of the while cycle until he chose a valid value
<b class="nc">&nbsp;                                    logCreator.log(&quot;Player &quot; + host.getPlayer().getNickname() + &quot; has not correctly answered&quot;);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                        } else {
<b class="nc">&nbsp;                            logCreator.log(&quot;Player &quot; + host.getPlayer().getNickname() + &quot; has not answered&quot;);</b>
<b class="nc">&nbsp;                            this.kickPlayer(host);</b>
<b class="nc">&nbsp;                            correctAnswer = true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        logCreator.log(&quot;Expected players obtained : &quot; + this.matchInfo.getExpectedPlayers() + &quot; from &quot; + this.getOnlinePlayerInfo().getFirst().getPlayer().getNickname());</b>
&nbsp;
<b class="fc">&nbsp;        synchronized (this) {</b>
&nbsp;
&nbsp;            // Wait for the specified number of expected players to join
<b class="fc">&nbsp;            while (this.getOnlinePlayerInfo().size() &lt; this.matchInfo.getExpectedPlayers()) {</b>
&nbsp;                try {
<b class="fc">&nbsp;                    this.wait();</b>
<b class="nc">&nbsp;                } catch (InterruptedException ignore) {</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;        //the number of players must be exactly the one specified by the host
<b class="pc">&nbsp;        while (this.getOnlinePlayerInfo().size() &gt; this.matchInfo.getExpectedPlayers()) {</b>
<b class="nc">&nbsp;            logCreator.log(&quot;Too many players have joined the match&quot;);</b>
<b class="nc">&nbsp;            this.kickPlayer(this.getOnlinePlayerInfo().getLast());</b>
&nbsp;        }
&nbsp;
&nbsp;        // Updates state of the match to turn of the first player
<b class="fc">&nbsp;        this.matchInfo.setStatus(MatchState.Player1);</b>
<b class="fc">&nbsp;        logCreator.log(&quot;Match state updated from \&quot;Waiting\&quot; to \&quot;Player 1\&quot;&quot;);</b>
&nbsp;
&nbsp;
&nbsp;        // Adds all players to the match (match of the model)
<b class="fc">&nbsp;        for (PlayerInfo playerInfo : this.getOnlinePlayerInfo()) {</b>
&nbsp;            try { //each online player is added to the match and the state of their turn is StarterCard
<b class="fc">&nbsp;                this.matchInfo.getMatch().addPlayer(playerInfo.getPlayer());</b>
<b class="fc">&nbsp;                playerInfo.setState(State.StarterCard);</b>
<b class="fc">&nbsp;                logCreator.log(&quot;Player &quot; + playerInfo.getPlayer().getNickname() + &quot; added to the model&quot;);</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                logCreator.log(&quot;Failed to add player to model: &quot; + playerInfo.getPlayer().getNickname());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Prepares the match.
<b class="fc">&nbsp;        this.matchInfo.getMatch().start();</b>
<b class="fc">&nbsp;        this.turnNumber = 1;</b>
&nbsp;
&nbsp;        // First save of the game
<b class="fc">&nbsp;        this.saveMatch();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Manages the game logic of the specified player if it is online.
&nbsp;     *
&nbsp;     * @param player player to manage.
&nbsp;     */
&nbsp;    private synchronized void player(Player player) {
<b class="fc">&nbsp;        if (player == null) {</b>
<b class="fc">&nbsp;            logCreator.log(&quot;Player is null&quot;);</b>
<b class="fc">&nbsp;            updateMatchStatus(); //set match state to the next player turn</b>
&nbsp;            return;
&nbsp;        }
<b class="fc">&nbsp;        PlayerInfo playerInfo = this.findPlayer(player);</b>
<b class="pc">&nbsp;        if (playerInfo == null) {</b>
<b class="nc">&nbsp;            logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; not found and skipped&quot;);</b>
<b class="nc">&nbsp;            updateMatchStatus();</b>
&nbsp;        }
&nbsp;
<b class="pc">&nbsp;        if(playerInfo!=null &amp;&amp; playerInfo.getState()!=null){</b>
<b class="pc">&nbsp;        switch (playerInfo.getState()) {</b>
&nbsp;            //switch according to the state of the turn of the player
&nbsp;            case StarterCard -&gt; {
<b class="fc">&nbsp;                logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; has to place the starter card&quot;);</b>
&nbsp;
&nbsp;                // Compute starter state itself
<b class="fc">&nbsp;                this.starterState(playerInfo);</b>
&nbsp;
&nbsp;                // Updates the view of each online player with information about current one (player)
<b class="fc">&nbsp;                for (PlayerInfo playerInfo1 : this.getOnlinePlayerInfo()) {</b>
<b class="fc">&nbsp;                    updatePlayerMessage update = new updatePlayerMessage(player, playerInfo1.getPlayer().getNickname());</b>
<b class="fc">&nbsp;                    playerInfo1.getConnection().sendUpdatePlayer(update); //sends message to each player</b>
&nbsp;                }
&nbsp;
&nbsp;                // End turn and update states
&nbsp;                //If the player is online
<b class="pc">&nbsp;                if (this.getOnlinePlayerInfo().contains(playerInfo)) {</b>
<b class="fc">&nbsp;                    logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; placed the starter card&quot;);</b>
<b class="fc">&nbsp;                    playerInfo.setState(State.Objective); //set the state of his turn to Objective</b>
<b class="fc">&nbsp;                    playerInfo.getPlayer().initialHand(); //draws cards</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                this.updateMatchStatus();</b>
&nbsp;
&nbsp;                // Saves the progress of the game
<b class="fc">&nbsp;                this.saveMatch();</b>
&nbsp;            }
&nbsp;            case Objective -&gt; {
<b class="fc">&nbsp;                logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; has to choose an objective&quot;);</b>
&nbsp;
&nbsp;                // Compute objective state itself
<b class="fc">&nbsp;                this.objectiveState(playerInfo);</b>
&nbsp;
&nbsp;                // Updates the view of each online player with information about current one (player)
<b class="fc">&nbsp;                for (PlayerInfo playerInfo1 : this.getOnlinePlayerInfo()) {</b>
<b class="fc">&nbsp;                    updatePlayerMessage update = new updatePlayerMessage(player, playerInfo1.getPlayer().getNickname());</b>
<b class="fc">&nbsp;                    playerInfo1.getConnection().sendUpdatePlayer(update);</b>
&nbsp;                }
&nbsp;
&nbsp;                // End turn and update states
<b class="pc">&nbsp;                if (this.getOnlinePlayerInfo().contains(playerInfo)) {</b>
<b class="fc">&nbsp;                    logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; has correctly chosen an objective&quot;);</b>
<b class="pc">&nbsp;                    if (this.matchInfo.isLastTurn())</b>
<b class="nc">&nbsp;                        playerInfo.setState(State.EndGame);</b>
&nbsp;                    else
<b class="fc">&nbsp;                        playerInfo.setState(State.PlaceCard); //set the state of the player&#39;s turn to PlaceCard</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                this.updateMatchStatus();</b>
&nbsp;
&nbsp;                // Saves the progress of the game
<b class="fc">&nbsp;                this.saveMatch();</b>
&nbsp;            }
&nbsp;            case PlaceCard -&gt; {
<b class="fc">&nbsp;                logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; starts normal turn and has to place a card&quot;);</b>
&nbsp;
&nbsp;                // Check if the current player can place a card
<b class="fc">&nbsp;                boolean canPlace = true;</b>
<b class="pc">&nbsp;                if (playerInfo.getPlayer().getPlayerArea().getAvailablePosition().isEmpty()) {</b>
<b class="nc">&nbsp;                    logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; cannot place a card. Ending his turn.&quot;);</b>
&nbsp;                    //if the player does not possess any available position in his area the state of the match is set to his next player&#39;s turn
<b class="nc">&nbsp;                    this.updateMatchStatus();</b>
<b class="nc">&nbsp;                    canPlace = false;</b>
&nbsp;                } else {
&nbsp;                    // Compute place card state itself
<b class="fc">&nbsp;                    this.placeCardState(playerInfo);</b>
&nbsp;                }
&nbsp;
&nbsp;                // Updates the view of each online player with information about current one (player)
<b class="fc">&nbsp;                for (PlayerInfo playerInfo1 : this.getOnlinePlayerInfo()) {</b>
<b class="fc">&nbsp;                    updatePlayerMessage update = new updatePlayerMessage(player, playerInfo1.getPlayer().getNickname());</b>
<b class="fc">&nbsp;                    playerInfo1.getConnection().sendUpdatePlayer(update);</b>
&nbsp;                }
&nbsp;
&nbsp;                // Update the state of player&#39;s turn to PickCard
<b class="pc">&nbsp;                if (this.getOnlinePlayerInfo().contains(playerInfo) &amp;&amp; canPlace) {</b>
<b class="fc">&nbsp;                    playerInfo.setState(State.PickCard);</b>
&nbsp;                }
&nbsp;
&nbsp;                /*
&nbsp;                Match status is not updated, because this player has yet to pick a card to finish his turn.
&nbsp;                 */
&nbsp;                // Saves the progress of the game
<b class="fc">&nbsp;                this.saveMatch();</b>
&nbsp;            }
&nbsp;            case PickCard -&gt; {
&nbsp;
<b class="pc">&nbsp;                if (this.matchInfo.getMatch().getCommonArea().getTableCards().isEmpty()</b>
<b class="pc">&nbsp;                        || this.getMatch().getCommonArea().getTableCards().stream().noneMatch(Objects::nonNull)){</b>
<b class="nc">&nbsp;                    logCreator.log(&quot;Common area is empty, player &quot; + player.getNickname() + &quot; cannot pick a card. Ending his turn.&quot;);</b>
&nbsp;
&nbsp;                } else {
<b class="fc">&nbsp;                    logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; has to pick a card from common area&quot;);</b>
&nbsp;
&nbsp;                    // Compute pick card state itself
<b class="fc">&nbsp;                    this.pickCardState(playerInfo);</b>
&nbsp;
&nbsp;                    // Updates the view of each online player with information about current one (player)
<b class="fc">&nbsp;                    for (PlayerInfo playerInfo1 : this.getOnlinePlayerInfo()) {</b>
<b class="fc">&nbsp;                        updatePlayerMessage update = new updatePlayerMessage(player, playerInfo1.getPlayer().getNickname());</b>
<b class="fc">&nbsp;                        playerInfo1.getConnection().sendUpdatePlayer(update);</b>
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; has ended his normal turn&quot;);</b>
&nbsp;                }
&nbsp;
&nbsp;                // End turn
&nbsp;                // Update all states, if this is last turn, next state of the player&#39;s turn will be EndGame, else it will be PlaceCard
<b class="pc">&nbsp;                if (this.getOnlinePlayerInfo().contains(playerInfo)) {</b>
<b class="pc">&nbsp;                    if (this.matchInfo.isLastTurn())</b>
<b class="nc">&nbsp;                        playerInfo.setState(State.EndGame);</b>
&nbsp;                    else
<b class="fc">&nbsp;                        playerInfo.setState(State.PlaceCard);</b>
&nbsp;                }
&nbsp;                //update the state of the match
<b class="fc">&nbsp;                this.updateMatchStatus();</b>
&nbsp;
&nbsp;                // Saves the progress of the game
<b class="fc">&nbsp;                this.saveMatch();</b>
&nbsp;
&nbsp;
&nbsp;            }
&nbsp;            case LastTurn -&gt; {
<b class="nc">&nbsp;                logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; plays his last turn&quot;);</b>
&nbsp;
<b class="nc">&nbsp;                if (playerInfo.getPlayer().getPlayerArea().getAvailablePosition().isEmpty()) {</b>
<b class="nc">&nbsp;                    logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; cannot place a card. Ending his turn.&quot;);</b>
<b class="nc">&nbsp;                    this.updateMatchStatus();</b>
&nbsp;                } else {
&nbsp;                    // Compute place card state itself
<b class="nc">&nbsp;                    this.placeCardState(playerInfo);</b>
&nbsp;                }
&nbsp;
&nbsp;                // Updates the view of each online player with information about current one (player)
<b class="nc">&nbsp;                for (PlayerInfo playerInfo1 : this.getOnlinePlayerInfo()) {</b>
<b class="nc">&nbsp;                    updatePlayerMessage update = new updatePlayerMessage(player, playerInfo1.getPlayer().getNickname());</b>
<b class="nc">&nbsp;                    playerInfo1.getConnection().sendUpdatePlayer(update);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; has ended his last turn&quot;);</b>
&nbsp;
&nbsp;                // Update the state of the player&#39;s turn from LastTurn to EndGame
<b class="nc">&nbsp;                if (this.getOnlinePlayerInfo().contains(playerInfo))</b>
<b class="nc">&nbsp;                    playerInfo.setState(State.EndGame);</b>
&nbsp;
<b class="nc">&nbsp;                switch (this.matchInfo.getStatus()) {</b>
&nbsp;                    //update the state of the match, if the cycle of the players&#39; turn is completed match state is set to EndGame
<b class="nc">&nbsp;                    case Player1 -&gt; this.matchInfo.setStatus(MatchState.Player2);</b>
<b class="nc">&nbsp;                    case Player2 -&gt; this.matchInfo.setStatus(MatchState.Player3);</b>
<b class="nc">&nbsp;                    case Player3 -&gt; this.matchInfo.setStatus(MatchState.Player4);</b>
<b class="nc">&nbsp;                    case Player4 -&gt; this.matchInfo.setStatus(MatchState.Endgame);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                this.saveMatch();</b>
&nbsp;            }
&nbsp;        }}
&nbsp;
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Updates the status of the match.
&nbsp;     */
&nbsp;    private void updateMatchStatus() {
<b class="pc">&nbsp;        switch (this.matchInfo.getStatus()) {</b>
&nbsp;            //the match state is updated to the player&#39;s turn
<b class="fc">&nbsp;            case Player1 -&gt; this.matchInfo.setStatus(MatchState.Player2);</b>
<b class="fc">&nbsp;            case Player2 -&gt; this.matchInfo.setStatus(MatchState.Player3);</b>
<b class="fc">&nbsp;            case Player3 -&gt; this.matchInfo.setStatus(MatchState.Player4);</b>
<b class="fc">&nbsp;            case Player4 -&gt; this.matchInfo.setStatus(MatchState.Player1);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Manages the StarterCard state of a player.
&nbsp;     *
&nbsp;     * @param playerInfo data about the player to manage.
&nbsp;     */
&nbsp;    private void starterState(PlayerInfo playerInfo) {
<b class="fc">&nbsp;        Player player = playerInfo.getPlayer();</b>
&nbsp;
&nbsp;        // Draw a StarterCard if player has none in hand
<b class="fc">&nbsp;        if (playerInfo.getPlayer().getPlayerHand().getPlaceableCards().stream().</b>
<b class="pc">&nbsp;                noneMatch(PlaceableCard::isStarter))</b>
<b class="fc">&nbsp;            playerInfo.getPlayer().drawStarter();</b>
&nbsp;
&nbsp;        // Sends currentStateMessage to all online players with information about current player (player)
<b class="fc">&nbsp;        for (PlayerInfo playerInfo1 : this.getOnlinePlayerInfo()) {</b>
<b class="fc">&nbsp;            currentStateMessage currState = new currentStateMessage(player, playerInfo1.getPlayer(), &quot;StarterCardState&quot;, this.matchInfo.isLastTurn(), this.onlinePlayersNicknames(), null, this.matchInfo.getID());</b>
<b class="fc">&nbsp;            playerInfo1.getConnection().sendCurrentState(currState);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Obtains side of the starter card
<b class="fc">&nbsp;        boolean correctAnswer = false;</b>
<b class="fc">&nbsp;        while (!correctAnswer) {</b>
&nbsp;
<b class="fc">&nbsp;            Future&lt;starterCardMessage&gt; future = executor.submit(() -&gt; playerInfo.getConnection().getStaterCard());</b>
<b class="fc">&nbsp;            starterCardMessage starter = null;</b>
&nbsp;
&nbsp;            try {
&nbsp;                //waits 2 minutes to obtain starterCardMessage from client
<b class="fc">&nbsp;                starter = future.get(this.timeout, TimeUnit.MILLISECONDS);</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; has not answered&quot;);</b>
<b class="nc">&nbsp;                this.kickPlayer(playerInfo);</b>
&nbsp;                return;
&nbsp;            }
&nbsp;            //If we don&#39;t get the result of the task submitted to the executor within two minutes, an exception is thrown and player kicked
&nbsp;            //If we receive the starterCardMessage result but inNoResponse is set to true because client did not receive on time the input of the user from cli or gui
&nbsp;            //the player is kicked
&nbsp;            //If we receive the starterCardMessage result but the value is not valid, there will be another iteration of while cycle
<b class="pc">&nbsp;            if (starter != null) {</b>
&nbsp;
&nbsp;                // Checks if the client has properly given a response
<b class="pc">&nbsp;                if (starter.isNoResponse()) {</b>
<b class="nc">&nbsp;                    correctAnswer = true;</b>
<b class="nc">&nbsp;                    logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; has not answered&quot;);</b>
<b class="nc">&nbsp;                    this.kickPlayer(playerInfo);</b>
&nbsp;                } else {
&nbsp;                    // Checks if the answer is valid
<b class="pc">&nbsp;                    if (starter.getSide() == 0 || starter.getSide() == 1) {</b>
&nbsp;                         //if the answer is valid the card is placed
<b class="fc">&nbsp;                        playerInfo.getPlayer().placeStarter(starter.getSide());</b>
<b class="fc">&nbsp;                        correctAnswer = true;</b>
<b class="fc">&nbsp;                        playerInfo.getConnection().sendAnswer(true);</b>
<b class="fc">&nbsp;                        logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; has correctly answered&quot;);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        playerInfo.getConnection().sendAnswer(false);</b>
<b class="fc">&nbsp;                        logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; has not answered correctly&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                if (this.getOnlinePlayerInfo().contains(playerInfo)) {</b>
<b class="nc">&nbsp;                    logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; failed to answer&quot;);</b>
<b class="nc">&nbsp;                    this.kickPlayer(playerInfo);</b>
<b class="nc">&nbsp;                    correctAnswer = true;</b>
&nbsp;                }
&nbsp;                return;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Manages the Objective state of a player.
&nbsp;     *
&nbsp;     * @param playerInfo data about the player to manage.
&nbsp;     */
&nbsp;    private void objectiveState(PlayerInfo playerInfo) {
<b class="fc">&nbsp;        Player player = playerInfo.getPlayer();</b>
&nbsp;
&nbsp;        // Draw two objective cards if there are none
<b class="pc">&nbsp;        if (playerInfo.getSavedObjectives() == null)</b>
<b class="fc">&nbsp;            playerInfo.setSavedObjectives(playerInfo.getPlayer().drawObjectives());</b>
&nbsp;
&nbsp;        // Sends currentStateMessage to all online players with information about current player (player)
<b class="fc">&nbsp;        for (PlayerInfo playerInfo1 : this.getOnlinePlayerInfo()) {</b>
<b class="fc">&nbsp;            currentStateMessage currState = new currentStateMessage(player, playerInfo1.getPlayer(), &quot;objectiveState&quot;, this.matchInfo.isLastTurn(), this.onlinePlayersNicknames(), this.matchInfo.getMatch().getCommonObjective(), this.matchInfo.getID());</b>
<b class="fc">&nbsp;            playerInfo1.getConnection().sendCurrentState(currState);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        boolean correctAnswer = false;</b>
<b class="fc">&nbsp;        while (!correctAnswer) {</b>
&nbsp;            //creates an ArrayList&lt;ObjectiveCard&gt; with the objective cards in the savedObjectives array of PlayerInfo
<b class="fc">&nbsp;            ArrayList&lt;ObjectiveCard&gt; objectives = new ArrayList&lt;&gt;(Arrays.asList(playerInfo.getSavedObjectives()));</b>
<b class="fc">&nbsp;            Future&lt;objectiveCardMessage&gt; future = executor.submit(() -&gt; playerInfo.getConnection().getChosenObjective(objectives));</b>
<b class="fc">&nbsp;            objectiveCardMessage objective = null;</b>
&nbsp;
&nbsp;            try {
&nbsp;                //waits for receive the objectiveCardMessage from client
<b class="fc">&nbsp;                objective = future.get(this.timeout, TimeUnit.MILLISECONDS);</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; has not answered&quot;);</b>
<b class="nc">&nbsp;                this.kickPlayer(playerInfo);</b>
&nbsp;                return;
&nbsp;            }
&nbsp;
<b class="pc">&nbsp;            if (objective != null) {</b>
&nbsp;                // Checks if the client has properly given a response
<b class="pc">&nbsp;                if (objective.isNoResponse()) {</b>
<b class="nc">&nbsp;                    correctAnswer = true;</b>
<b class="nc">&nbsp;                    this.kickPlayer(playerInfo);</b>
&nbsp;                } else {
&nbsp;                    // Checks if the answer is valid
<b class="pc">&nbsp;                    if (objective.getChoice() == 1 || objective.getChoice() == 2) {</b>
<b class="fc">&nbsp;                        playerInfo.getPlayer().pickObjectiveCard(objective.getChoice(), playerInfo.getSavedObjectives());</b>
<b class="fc">&nbsp;                        correctAnswer = true;</b>
<b class="fc">&nbsp;                        playerInfo.getConnection().sendAnswer(true);</b>
<b class="fc">&nbsp;                        logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; has correctly answered&quot;);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        playerInfo.getConnection().sendAnswer(false);</b>
<b class="fc">&nbsp;                        logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; has not correctly answered&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; failed to answer&quot;);</b>
<b class="nc">&nbsp;                this.kickPlayer(playerInfo);</b>
<b class="nc">&nbsp;                correctAnswer = true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Manages the PlaceCard state of a player.
&nbsp;     *
&nbsp;     * @param playerInfo data about the player to manage.
&nbsp;     */
&nbsp;    private void placeCardState(PlayerInfo playerInfo) {
<b class="fc">&nbsp;        Player player = playerInfo.getPlayer();</b>
&nbsp;
&nbsp;        // Sends currentStateMessage to all online players with information about current player (player)
<b class="fc">&nbsp;        for (PlayerInfo playerInfo1 : this.getOnlinePlayerInfo()) {</b>
<b class="fc">&nbsp;            currentStateMessage currState = new currentStateMessage(player, playerInfo1.getPlayer(), &quot;PlaceTurnState&quot;, this.matchInfo.isLastTurn(), this.onlinePlayersNicknames(), this.matchInfo.getMatch().getCommonObjective(), this.matchInfo.getID());</b>
<b class="fc">&nbsp;            playerInfo1.getConnection().sendCurrentState(currState);</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        // Asks client to place a card
<b class="fc">&nbsp;        boolean correctAnswer = false;</b>
<b class="fc">&nbsp;        while (!correctAnswer) {</b>
<b class="fc">&nbsp;            Future&lt;placeCardMessage&gt; future = executor.submit(() -&gt; playerInfo.getConnection().getPlaceCard());</b>
<b class="fc">&nbsp;            placeCardMessage placeCard = null;</b>
&nbsp;
&nbsp;            try { //waits to receive the placeCardMessage from client
<b class="fc">&nbsp;                placeCard = future.get(this.timeout, TimeUnit.MILLISECONDS);</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; has not answered&quot;);</b>
<b class="nc">&nbsp;                this.kickPlayer(playerInfo);</b>
&nbsp;                return;
&nbsp;            }
&nbsp;
<b class="pc">&nbsp;            if (placeCard != null) {</b>
&nbsp;                // Checks if the client has properly given a response
<b class="pc">&nbsp;                if (placeCard.isNoResponse()) {</b>
<b class="nc">&nbsp;                    correctAnswer = true;</b>
<b class="nc">&nbsp;                    this.kickPlayer(playerInfo);</b>
&nbsp;                } else {
&nbsp;                    // Checks if the answer is valid
<b class="fc">&nbsp;                    int card = placeCard.getCard();</b>
<b class="fc">&nbsp;                    int x = placeCard.getRow();</b>
<b class="fc">&nbsp;                    int y = placeCard.getColumn();</b>
<b class="fc">&nbsp;                    int side = placeCard.getFront();</b>
&nbsp;
&nbsp;                    try {
<b class="fc">&nbsp;                        playerInfo.getPlayer().playTurn(card, x, y, side);</b>
<b class="fc">&nbsp;                        playerInfo.getConnection().sendAnswer(true);</b>
<b class="fc">&nbsp;                        logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; has correctly answered&quot;);</b>
<b class="fc">&nbsp;                        correctAnswer = true;</b>
<b class="fc">&nbsp;                    } catch (noPlaceCardException e) {</b>
&nbsp;                        //if the user chose a card or positions that are not available noPlaceCardException is thrown and a negative responseMessage is sent
<b class="fc">&nbsp;                        playerInfo.getConnection().sendAnswer(false);</b>
<b class="fc">&nbsp;                        logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; has not correctly answered&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; failed to answer&quot;);</b>
<b class="nc">&nbsp;                this.kickPlayer(playerInfo);</b>
&nbsp;               // correctAnswer = true;
&nbsp;                return;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Manages the PickCard state of a player.
&nbsp;     *
&nbsp;     * @param playerInfo data about the player to manage.
&nbsp;     */
&nbsp;    private void pickCardState(PlayerInfo playerInfo) {
<b class="fc">&nbsp;        Player player = playerInfo.getPlayer();</b>
&nbsp;
&nbsp;        // Sends currentStateMessage to all online players with information about current player (player)
<b class="fc">&nbsp;        for (PlayerInfo playerInfo1 : this.getOnlinePlayerInfo()) {</b>
<b class="fc">&nbsp;            currentStateMessage currState = new currentStateMessage(player, playerInfo1.getPlayer(), &quot;PickTurnState&quot;, this.matchInfo.isLastTurn(), this.onlinePlayersNicknames(), this.matchInfo.getMatch().getCommonObjective(), this.matchInfo.getID());</b>
<b class="fc">&nbsp;            playerInfo1.getConnection().sendCurrentState(currState);</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        // If the client is still online, it proceeds to ask to pick a card
&nbsp;        boolean correctAnswer;
<b class="pc">&nbsp;        if (this.getOnlinePlayerInfo().contains(playerInfo)) {</b>
<b class="fc">&nbsp;            correctAnswer = false;</b>
<b class="fc">&nbsp;            while (!correctAnswer) {</b>
<b class="fc">&nbsp;                Future&lt;pickCardMessage&gt; future = executor.submit(() -&gt; playerInfo.getConnection().getChosenPick());</b>
<b class="fc">&nbsp;                pickCardMessage pickCard = null;</b>
&nbsp;
&nbsp;                try {
<b class="fc">&nbsp;                    pickCard = future.get(this.timeout, TimeUnit.MILLISECONDS);</b>
<b class="nc">&nbsp;                } catch (Exception e) {</b>
<b class="nc">&nbsp;                    logCreator.log(&quot;Player &quot; + player.getNickname() + &quot;has not answered&quot;);</b>
<b class="nc">&nbsp;                    this.kickPlayer(playerInfo);</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;
<b class="pc">&nbsp;                if (pickCard != null) {</b>
&nbsp;                    // Checks if the client has properly given a response
<b class="pc">&nbsp;                    if (pickCard.isNoResponse()) {</b>
<b class="nc">&nbsp;                        correctAnswer = true;</b>
<b class="nc">&nbsp;                        this.kickPlayer(playerInfo);</b>
&nbsp;                    } else {
&nbsp;                        // Checks if the pickCardMessage has a valid value,
&nbsp;                        // otherwise InvalidIdException is thrown, a negative responseMessage is sent, there will be another iteration of while cycle
&nbsp;                        try {
<b class="fc">&nbsp;                            playerInfo.getPlayer().pickNewCard(pickCard.getCard());</b>
<b class="fc">&nbsp;                            correctAnswer = true;</b>
<b class="fc">&nbsp;                            playerInfo.getConnection().sendAnswer(true);</b>
<b class="fc">&nbsp;                            logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; has correctly answered&quot;);</b>
<b class="nc">&nbsp;                        } catch (InvalidIdException e) {</b>
<b class="nc">&nbsp;                            playerInfo.getConnection().sendAnswer(false);</b>
<b class="nc">&nbsp;                            logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; has not correctly answered&quot;);</b>
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    logCreator.log(&quot;Player &quot; + player.getNickname() + &quot; failed to answer&quot;);</b>
<b class="nc">&nbsp;                    this.kickPlayer(playerInfo);</b>
&nbsp;                    // correctAnswer = true;
&nbsp;                    return;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Manages the EndGame state of the match.
&nbsp;     * Calculates score and number of objectives achieved by each player and sends a declareWinnerMessage to the client
&nbsp;     */
&nbsp;    private void endgame() {
<b class="fc">&nbsp;        logCreator.log(&quot;ENDGAME&quot;);</b>
&nbsp;        // Sends current state messages to all online players
<b class="fc">&nbsp;        for (PlayerInfo playerInfo1 : this.getOnlinePlayerInfo()) {</b>
&nbsp;            //currentPlayer is null as we don&#39;t need to update other players about him anymore
<b class="fc">&nbsp;            currentStateMessage currState = new currentStateMessage(null, playerInfo1.getPlayer(), &quot;endGameState&quot;, this.matchInfo.isLastTurn(), this.onlinePlayersNicknames(), this.matchInfo.getMatch().getCommonObjective(), this.matchInfo.getID());</b>
<b class="fc">&nbsp;            playerInfo1.getConnection().sendCurrentState(currState);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        HashMap&lt;String, Integer&gt; scores = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        HashMap&lt;String, Integer&gt; numberOfObjects = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        ArrayList&lt;Player&gt; players = this.getOnlinePlayerInfo().stream()</b>
<b class="fc">&nbsp;                .map(PlayerInfo::getPlayer)</b>
<b class="fc">&nbsp;                .collect(Collectors.toCollection(ArrayList::new));</b>
&nbsp;
&nbsp;        // Compute all points and number of objective accomplished
<b class="fc">&nbsp;        for (Player player : players) {</b>
<b class="fc">&nbsp;            int score = player.getScore();</b>
<b class="fc">&nbsp;            int count = 0;</b>
&nbsp;            //update score and count given by private objective
<b class="pc">&nbsp;            if (player.getObjective() != null) {</b>
<b class="fc">&nbsp;                score += player.getPlayerArea().checkPattern(player.getObjective());</b>
<b class="fc">&nbsp;                count += player.getPlayerArea().countPattern(player.getObjective());</b>
&nbsp;            }
&nbsp;            //update score and count given by first common objective
<b class="pc">&nbsp;            if (matchInfo.getMatch().getCommonObjective()[0] != null) {</b>
<b class="fc">&nbsp;                score += player.getPlayerArea().checkPattern(this.matchInfo.getMatch().getCommonObjective()[0]);</b>
<b class="fc">&nbsp;                count += player.getPlayerArea().countPattern(this.matchInfo.getMatch().getCommonObjective()[0]);</b>
&nbsp;            }
&nbsp;            //update score and count given by second common objective
<b class="pc">&nbsp;            if (matchInfo.getMatch().getCommonObjective()[1] != null) {</b>
<b class="fc">&nbsp;                score += player.getPlayerArea().checkPattern(this.matchInfo.getMatch().getCommonObjective()[1]);</b>
<b class="fc">&nbsp;                count += player.getPlayerArea().countPattern(this.matchInfo.getMatch().getCommonObjective()[1]);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            scores.put(player.getNickname(), score);</b>
<b class="fc">&nbsp;            numberOfObjects.put(player.getNickname(), count);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        for (PlayerInfo playerInfo1 : this.getOnlinePlayerInfo()) {</b>
&nbsp;             //send declareWinnerMessage to each online player
<b class="fc">&nbsp;            playerInfo1.getConnection().sendEndGame(scores, numberOfObjects);</b>
&nbsp;        }
&nbsp;        //update the state of the match from EndGame to KickingPlayers
<b class="fc">&nbsp;        this.matchInfo.setStatus(MatchState.KickingPlayers);</b>
&nbsp;
<b class="fc">&nbsp;        this.saveMatch();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Kick out of the match each online player
&nbsp;     */
&nbsp;    private void kickingPlayers() {
<b class="fc">&nbsp;        logCreator.log(&quot;Kicking out all players&quot;);</b>
<b class="fc">&nbsp;        this.getOnlinePlayerInfo().forEach(this::kickPlayer);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Finds a player by their nickname.
&nbsp;     *
&nbsp;     * @param player The player object to search for.
&nbsp;     * @return The player information if found, or {@code null} if not found.
&nbsp;     */
&nbsp;    private PlayerInfo findPlayer(Player player) {
<b class="fc">&nbsp;        return this.getOnlinePlayerInfo().stream()</b>
<b class="fc">&nbsp;                .filter(playerInfo -&gt; Objects.equals(player.getNickname(), playerInfo.getPlayer().getNickname()))</b>
<b class="fc">&nbsp;                .findFirst()</b>
<b class="fc">&nbsp;                .orElse(null);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the number of online players is correct.
&nbsp;     * If only one player remains, he is declared the winner.
&nbsp;     * If no players remain, the match is over.
&nbsp;     */
&nbsp;    private void checkOnlinePlayersNumber() {
&nbsp;        // This method must be used at the end of every turn
&nbsp;
<b class="fc">&nbsp;        this.checkPlayersConnections();</b>
&nbsp;
<b class="fc">&nbsp;        Timer timer = new Timer();</b>
<b class="fc">&nbsp;        Timer timerCheckConnections = new Timer();</b>
&nbsp;
<b class="fc">&nbsp;        synchronized (this) {</b>
<b class="fc">&nbsp;            if (this.getOnlinePlayerInfo().size() == 1) {</b>
&nbsp;                // Waits for a timeout.
&nbsp;                // Then, if a player remains, he is declared the new winner
<b class="fc">&nbsp;                MatchManager manager = this;</b>
<b class="fc">&nbsp;                TimerTask task = new TimerTask() {</b>
&nbsp;                    @Override
&nbsp;                    public void run() {
<b class="fc">&nbsp;                        synchronized (manager) {</b>
<b class="fc">&nbsp;                            manager.checkPlayersConnections(); //update the ArrayList of online players</b>
<b class="pc">&nbsp;                            if (manager.getOnlinePlayerInfo().size() == 1) {</b>
<b class="fc">&nbsp;                                manager.matchInfo.setStatus(MatchState.Endgame);</b>
<b class="fc">&nbsp;                                logCreator.log(&quot;Only one player remains, he is the winner&quot;);</b>
<b class="fc">&nbsp;                                manager.notifyAll();</b>
&nbsp;                            }
&nbsp;
<b class="pc">&nbsp;                            if (manager.getOnlinePlayerInfo().isEmpty()) {</b>
<b class="nc">&nbsp;                                manager.matchInfo.setStatus(MatchState.KickingPlayers);</b>
<b class="nc">&nbsp;                                logCreator.log(&quot;No players remain, the match is over&quot;);</b>
<b class="nc">&nbsp;                                manager.notifyAll();</b>
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                };
&nbsp;                //task is performed after 2 minutes
<b class="fc">&nbsp;                timer.schedule(task, this.timeout);</b>
&nbsp;
&nbsp;
&nbsp;                // Timer taskCheckConnections that checks every 15 seconds if all players are still connected
<b class="fc">&nbsp;                TimerTask taskCheckConnections = new TimerTask() {</b>
&nbsp;                    @Override
&nbsp;                    public void run() {
<b class="fc">&nbsp;                        synchronized (manager) {</b>
<b class="fc">&nbsp;                            manager.checkPlayersConnections(); //the ArrayList of online players is updated</b>
<b class="fc">&nbsp;                            manager.notifyAll(); //wakes up threads synchronized on manager</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                };
&nbsp;                //taskCheckConnections is performed every 15 seconds
<b class="fc">&nbsp;                timerCheckConnections.schedule(taskCheckConnections, 0, 15000);</b>
&nbsp;            }
&nbsp;
&nbsp;            //while there is only one online player and the match is not in state EndGame or KickingPlayers the current thread waits,
&nbsp;            //it can be awakened by the manager.notifyAll() and methods wakeUpPlayer, addPlayerInfo
<b class="fc">&nbsp;            while (this.getOnlinePlayerInfo().size() == 1</b>
<b class="fc">&nbsp;                    &amp;&amp; this.matchInfo.getStatus() != MatchState.Endgame</b>
<b class="pc">&nbsp;                    &amp;&amp; this.matchInfo.getStatus() != MatchState.KickingPlayers) {</b>
&nbsp;                try {
<b class="fc">&nbsp;                    this.wait();</b>
<b class="nc">&nbsp;                } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;                    logCreator.log(&quot;Thread interrupted while waiting for players to join again&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (this.getOnlinePlayerInfo().isEmpty()) {</b>
&nbsp;                // Closes and doesn&#39;t save the match
<b class="fc">&nbsp;                logCreator.log(&quot;No player remains, closing the match&quot;);</b>
<b class="fc">&nbsp;                this.matchInfo.setStatus(MatchState.KickingPlayers);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Eventually cancels the timer
<b class="fc">&nbsp;            timer.cancel();</b>
<b class="fc">&nbsp;            timerCheckConnections.cancel();</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a list of nicknames of all online players
&nbsp;     *
&nbsp;     * @return list of online players
&nbsp;     */
&nbsp;    private ArrayList&lt;String&gt; onlinePlayersNicknames() {
<b class="fc">&nbsp;        return this.matchInfo.getAllPlayersInfo().stream()</b>
<b class="fc">&nbsp;                .filter(playerInfo -&gt; playerInfo.getConnection() != null)</b>
<b class="fc">&nbsp;                .map(playerInfo -&gt; playerInfo.getPlayer().getNickname())</b>
<b class="fc">&nbsp;                .collect(Collectors.toCollection(ArrayList::new));</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Loads a saved match and waits for the right number of players to join. Then starts the game.
&nbsp;     */
&nbsp;    protected synchronized void loadAndWaitSavedMatch() {
<b class="fc">&nbsp;        logCreator.log(&quot;Saved match &quot; + this.matchInfo.getID() + &quot; loaded: in state &quot; + this.matchInfo.getStatus());</b>
<b class="fc">&nbsp;        logCreator.log(&quot;Waiting for players; expected players: &quot; + this.matchInfo.getExpectedPlayers() + &quot; players to be loaded: &quot; + this.matchInfo.getAllPlayersInfo());</b>
&nbsp;
&nbsp;        // Sets all players of the saved match to offline
<b class="fc">&nbsp;        this.matchInfo.getAllPlayersInfo().forEach(this.matchInfo::setOffline);</b>
&nbsp;
&nbsp;        // Waits for all players to join, we wait as long as the number of online players is lower than the number of expected players
<b class="fc">&nbsp;        while (this.getOnlinePlayerInfo().size() &lt; this.matchInfo.getExpectedPlayers()) {</b>
&nbsp;            try {
<b class="fc">&nbsp;                this.wait();</b>
<b class="nc">&nbsp;            } catch (InterruptedException ignore) {</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Kicks players that are not supposed to be in the match
<b class="pc">&nbsp;        while (this.getOnlinePlayerInfo().size() &gt; this.matchInfo.getExpectedPlayers()) {</b>
<b class="nc">&nbsp;            logCreator.log(&quot;Too many players have joined the match&quot;);</b>
<b class="nc">&nbsp;            this.kickPlayer(this.getOnlinePlayerInfo().getLast());</b>
&nbsp;        }
&nbsp;        //if we are not in wait anymore the number of online players is reached the number of expected players, call the method run
<b class="fc">&nbsp;        this.run();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if all players are still connected.
&nbsp;     * If a player is not connected, he is kicked out of the match.
&nbsp;     */
&nbsp;    private synchronized void checkPlayersConnections() {
&nbsp;        // This method must be used at the end of every turn
&nbsp;
<b class="fc">&nbsp;        HashMap&lt;Future&lt;Boolean&gt;, PlayerInfo&gt; futures = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        ArrayList&lt;Future&lt;Boolean&gt;&gt; results = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;        // Sends a ping to all players
<b class="fc">&nbsp;        for (PlayerInfo playerInfo : this.getOnlinePlayerInfo()) {</b>
&nbsp;            //for each playerInfo object whose player is online, we submit to the executor a task to check if he is online
<b class="fc">&nbsp;            Future&lt;Boolean&gt; future = executor.submit(() -&gt; playerInfo.getConnection().isConnected(this.getOnlinePlayerInfo().stream()</b>
<b class="fc">&nbsp;                    .map(playerInfo1 -&gt; playerInfo1.getPlayer().getNickname())</b>
<b class="fc">&nbsp;                    .collect(Collectors.toCollection(ArrayList::new))));</b>
<b class="fc">&nbsp;            futures.put(future, playerInfo);</b>
&nbsp;        }
<b class="fc">&nbsp;        int timeout = 5;</b>
<b class="fc">&nbsp;        TimeUnit unit = TimeUnit.SECONDS;</b>
&nbsp;
&nbsp;        // Expects a response from all players
<b class="fc">&nbsp;        for (Future&lt;Boolean&gt; currFuture : futures.keySet()) {</b>
&nbsp;            //for each boolean key in futures, representing whether players are online or offline we submit to the executor a task to kick offline players
<b class="fc">&nbsp;            Future&lt;Boolean&gt; responseFuture = executor.submit(() -&gt; {</b>
&nbsp;                try {
<b class="fc">&nbsp;                    boolean response = currFuture.get(timeout, unit); //waits 5 seconds to obtain</b>
<b class="pc">&nbsp;                    if (!response) //if response is false, the player is offline, throws exception that will kick the player</b>
<b class="nc">&nbsp;                        throw new Exception();</b>
&nbsp;                    //logCreator.log(&quot;Player &quot; + futures.get(currFuture).getPlayer().getNickname() + &quot; is online&quot;);
<b class="fc">&nbsp;                    return true;</b>
<b class="fc">&nbsp;                } catch (Exception e) {</b>
<b class="fc">&nbsp;                    logCreator.log(&quot;Player &quot; + futures.get(currFuture).getPlayer().getNickname() + &quot; has not answered to ping&quot;);</b>
<b class="fc">&nbsp;                    this.kickPlayer(futures.get(currFuture));</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            });
&nbsp;            //results will contain objects of type Future&lt;Boolean&gt;, they will be true if we obtain in less than 5 seconds the result of the task that check players&#39; connection
<b class="fc">&nbsp;            results.add(responseFuture);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Waits for all tasks to complete, blocks the thread until we obtain the result for each element of the ArrayList results
<b class="fc">&nbsp;        for (Future&lt;Boolean&gt; future : results) {</b>
&nbsp;            try {
<b class="fc">&nbsp;                future.get();</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                logCreator.log(&quot;Failed to get response from player&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Uncomment to print the status of all players&#39; connections
&nbsp;        //this.matchInfo.printPlayersStatus();
&nbsp;
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-06-26 22:00</div>
</div>
</body>
</html>
