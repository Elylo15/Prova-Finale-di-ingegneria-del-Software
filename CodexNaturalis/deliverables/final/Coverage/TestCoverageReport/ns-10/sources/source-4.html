


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > PlayerArea</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">it.polimi.ingsw.model</a>
</div>

<h1>Coverage Summary for Class: PlayerArea (it.polimi.ingsw.model)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">PlayerArea</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (18/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    69,5%
  </span>
  <span class="absValue">
    (107/154)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87,8%
  </span>
  <span class="absValue">
    (201/229)
  </span>
</td>
</tr>
  <tr>
    <td class="name">PlayerArea$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (19/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    69,5%
  </span>
  <span class="absValue">
    (107/154)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87,8%
  </span>
  <span class="absValue">
    (202/230)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package it.polimi.ingsw.model;
&nbsp;
&nbsp;import it.polimi.ingsw.model.cards.Cell;
&nbsp;import it.polimi.ingsw.model.cards.ObjectiveCard;
&nbsp;import it.polimi.ingsw.model.cards.PlaceableCard;
&nbsp;import it.polimi.ingsw.model.cards.enumeration.Reign;
&nbsp;import it.polimi.ingsw.model.cards.enumeration.Resource;
&nbsp;import it.polimi.ingsw.model.cards.exceptions.noPlaceCardException;
&nbsp;
&nbsp;import java.io.Serializable;
&nbsp;import java.util.*;
&nbsp;import java.util.stream.Collectors;
&nbsp;import java.util.stream.Stream;
&nbsp;
&nbsp;/**
&nbsp; * This class represents a player&#39;s area in the game.
&nbsp; * It contains a matrix of cells and a list of permanent resources.
&nbsp; * It provides methods for adding cells, checking positions, placing cards, and checking patterns.
&nbsp; * It implements the Serializable interface.
&nbsp; */
&nbsp;public class PlayerArea implements Serializable {
&nbsp;
&nbsp;    private final HashMap&lt;ArrayList&lt;Integer&gt;, Cell&gt; CellMatrix;
&nbsp;    private final ArrayList&lt;Integer&gt; permanentResource;
&nbsp;
&nbsp;    /**
&nbsp;     * This is the constructor for the PlayerArea class.
&nbsp;     * It initializes the matrix of cells and the list of permanent resources.
&nbsp;     */
<b class="fc">&nbsp;    public PlayerArea() {</b>
<b class="fc">&nbsp;        this.CellMatrix = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        this.permanentResource = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; 9; i++) {</b>
<b class="fc">&nbsp;            this.permanentResource.add(0); //initialize to 0</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method returns the coordinates of a cell given its row and column.
&nbsp;     *
&nbsp;     * @param x The row of the cell.
&nbsp;     * @param y The column of the cell.
&nbsp;     * @return ArrayList&lt;Integer&gt; The coordinates of the cell.
&nbsp;     */
&nbsp;    private static ArrayList&lt;Integer&gt; getCoordinates(int x, int y) {
<b class="fc">&nbsp;        ArrayList&lt;Integer&gt; coordinates = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        coordinates.add(x);</b>
<b class="fc">&nbsp;        coordinates.add(y);</b>
<b class="fc">&nbsp;        return coordinates;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method checks if a cell exists at the given coordinates.
&nbsp;     *
&nbsp;     * @param x The row of the cell.
&nbsp;     * @param y The column of the cell.
&nbsp;     * @return boolean True if a cell exists at the given coordinates, false otherwise.
&nbsp;     */
&nbsp;    public boolean contains(int x, int y) {
<b class="fc">&nbsp;        ArrayList&lt;Integer&gt; coordinates = getCoordinates(x, y);</b>
<b class="fc">&nbsp;        return CellMatrix.containsKey(coordinates);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method returns a cell given its coordinates.
&nbsp;     *
&nbsp;     * @param x The row of the cell.
&nbsp;     * @param y The column of the cell.
&nbsp;     * @return Cell The cell at the given coordinates. If no cell exists at the given coordinates, it returns null.
&nbsp;     */
&nbsp;    private Cell getCell(int x, int y) {
<b class="fc">&nbsp;        ArrayList&lt;Integer&gt; coordinates = getCoordinates(x, y);</b>
<b class="fc">&nbsp;        return CellMatrix.get(coordinates);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method adds a cell to the player&#39;s area.
&nbsp;     *
&nbsp;     * @param cell The cell to add to the player&#39;s area.
&nbsp;     */
&nbsp;    public void addCell(Cell cell) {
<b class="fc">&nbsp;        ArrayList&lt;Integer&gt; coordinates = getCoordinates(cell.getRow(), cell.getColumn());</b>
<b class="fc">&nbsp;        CellMatrix.put(coordinates, cell);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method increases the stored counter of the given resource by 1.
&nbsp;     *
&nbsp;     * @param resource The resource to increase.
&nbsp;     */
&nbsp;    private void addPermanentResource(Resource resource) {
<b class="fc">&nbsp;        int selector = resourceSelector(resource);</b>
<b class="fc">&nbsp;        this.permanentResource.set(selector, this.permanentResource.get(selector) + 1);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method selects a resource and returns an integer that represents the resource.
&nbsp;     *
&nbsp;     * @param resource The resource to select.
&nbsp;     * @return int An integer that represents the resource.
&nbsp;     */
&nbsp;    private int resourceSelector(Resource resource) {
<b class="pc">&nbsp;        return switch (resource) {</b>
<b class="fc">&nbsp;            case Resource.Fungus -&gt; 0;</b>
<b class="fc">&nbsp;            case Resource.Insect -&gt; 1;</b>
<b class="fc">&nbsp;            case Resource.Animal -&gt; 2;</b>
<b class="fc">&nbsp;            case Resource.Plant -&gt; 3;</b>
<b class="fc">&nbsp;            case Resource.Manuscript -&gt; 4;</b>
<b class="fc">&nbsp;            case Resource.Quill -&gt; 5;</b>
<b class="fc">&nbsp;            case Resource.Inkwell -&gt; 6;</b>
<b class="fc">&nbsp;            case Resource.Empty -&gt; 7;</b>
<b class="fc">&nbsp;            case Resource.Blocked -&gt; 8;</b>
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method counts all resources, both permanent and non-permanent, in the player&#39;s area.
&nbsp;     *
&nbsp;     * @return A list of 8 counters:
&nbsp;     * 0. Counter for FUNGUS
&nbsp;     * 1. Counter for INSECT
&nbsp;     * 2. Counter for ANIMAL
&nbsp;     * 3. Counter for PLANT
&nbsp;     * 4. Counter for MANUSCRIPT
&nbsp;     * 5. Counter for QUILL
&nbsp;     * 6. Counter for INKWELL
&nbsp;     * 7. Counter for EMPTY
&nbsp;     * 8. Counter for BLOCKED
&nbsp;     */
&nbsp;    public ArrayList&lt;Integer&gt; getResources() {
<b class="fc">&nbsp;        ArrayList&lt;Integer&gt; resourceList = new ArrayList&lt;&gt;(permanentResource);</b>
&nbsp;        //stream of cells (values of cellMatrix), calls the method addResourceToList for each element in order to increase the number of the resource contained in the cell
<b class="fc">&nbsp;        CellMatrix.values().forEach((x) -&gt; addResourceToList(resourceList, x.getResource()));</b>
<b class="fc">&nbsp;        return resourceList;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method increases the counter of a resource in a list of counters.
&nbsp;     *
&nbsp;     * @param list     The list of counters.
&nbsp;     * @param resource The resource of which to increase the counter.
&nbsp;     */
&nbsp;    private void addResourceToList(ArrayList&lt;Integer&gt; list, Resource resource) {
&nbsp;
<b class="fc">&nbsp;        int selector = resourceSelector(resource);</b>
<b class="fc">&nbsp;        list.set(selector, list.get(selector) + 1);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method returns a list of available positions for placing a card.
&nbsp;     * A position is made of a square of four cells, and it is represented by the coordinates of its top-left cell.
&nbsp;     *
&nbsp;     * @return ArrayList&lt;Integer[]&gt; A list of positions where a card could be placed.
&nbsp;     */
&nbsp;    public ArrayList&lt;Integer[]&gt; getAvailablePosition() {
&nbsp;        /*
&nbsp;        For each available cell of coordinates x,y, there are the following positions to check:
&nbsp;        0. top-left (x-1, y-1)
&nbsp;        1. top-right (x-1, y)
&nbsp;        2. bottom-left (x, y-1)
&nbsp;        3. bottom-right (x, y)
&nbsp;         */
<b class="fc">&nbsp;        ArrayList&lt;Integer[]&gt; positions = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        CellMatrix.values().stream()</b>
<b class="fc">&nbsp;                .filter(Cell::isAvailable) //now the stream contains only available cells</b>
<b class="fc">&nbsp;                .forEach(cell -&gt; {</b>
<b class="fc">&nbsp;                    Integer[] pos0 = {cell.getRow() - 1, cell.getColumn() - 1};</b>
<b class="fc">&nbsp;                    Integer[] pos1 = {cell.getRow() - 1, cell.getColumn()};</b>
<b class="fc">&nbsp;                    Integer[] pos2 = {cell.getRow(), cell.getColumn() - 1};</b>
<b class="fc">&nbsp;                    Integer[] pos3 = {cell.getRow(), cell.getColumn()};</b>
&nbsp;                    //for each cell we check if its top-left, top-right, bottom-left neighbors and cell itself have available positions
&nbsp;
<b class="fc">&nbsp;                    if (this.checkPosition(pos0[0], pos0[1]))</b>
<b class="fc">&nbsp;                        positions.add(pos0);</b>
&nbsp;
<b class="fc">&nbsp;                    if (this.checkPosition(pos1[0], pos1[1]))</b>
<b class="fc">&nbsp;                        positions.add(pos1);</b>
&nbsp;
<b class="fc">&nbsp;                    if (this.checkPosition(pos2[0], pos2[1]))</b>
<b class="fc">&nbsp;                        positions.add(pos2);</b>
&nbsp;
<b class="fc">&nbsp;                    if (this.checkPosition(pos3[0], pos3[1]))</b>
<b class="fc">&nbsp;                        positions.add(pos3);</b>
&nbsp;                });
&nbsp;
<b class="fc">&nbsp;        return positions;</b>
&nbsp;
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method checks if a position is available to place a card.
&nbsp;     *
&nbsp;     * @param x The row of the position.
&nbsp;     * @param y The column of the position.
&nbsp;     * @return boolean True if a card can be placed at the given position, false otherwise.
&nbsp;     */
&nbsp;    public boolean checkPosition(int x, int y) {
&nbsp;        //Basic check: if a position is already taken
<b class="fc">&nbsp;        if (this.getCard(x, y) != null)</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;
&nbsp;        /*
&nbsp;          The cells to check are:
&nbsp;          (x  , y  )
&nbsp;          (x  , y+1)
&nbsp;          (x+1, y  )
&nbsp;          (x+1, y+1)
&nbsp;         */
&nbsp;        //Obtains the existing cells
<b class="fc">&nbsp;        ArrayList&lt;Cell&gt; position = new ArrayList&lt;&gt;();</b>
&nbsp;        //adds to position the cell in (x,y), the cell to its left, the cells below it to the right and to the left, if they are contained in the playerArea
<b class="fc">&nbsp;        if (this.contains(x, y))</b>
<b class="fc">&nbsp;            position.add(getCell(x, y));</b>
&nbsp;
<b class="fc">&nbsp;        if (this.contains(x, y + 1))</b>
<b class="fc">&nbsp;            position.add(getCell(x, y + 1));</b>
&nbsp;
<b class="fc">&nbsp;        if (this.contains(x + 1, y))</b>
<b class="fc">&nbsp;            position.add(getCell(x + 1, y));</b>
&nbsp;
<b class="fc">&nbsp;        if (this.contains(x + 1, y + 1))</b>
<b class="fc">&nbsp;            position.add(getCell(x + 1, y + 1));</b>
&nbsp;
&nbsp;        //check if there are existing cells
<b class="fc">&nbsp;        if (position.isEmpty())</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;
&nbsp;        //checks if all cells are available
<b class="fc">&nbsp;        if (position.stream().filter(Cell::isAvailable).count() &lt; position.size())</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;
&nbsp;        //checks if some cells share the same bottom card
<b class="fc">&nbsp;        if (position.stream().map(Cell::getBottomCard).distinct().count() &lt; position.size())</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;
&nbsp;
&nbsp;        //checks if blocked cells exists
<b class="pc">&nbsp;        return position.stream().noneMatch(a -&gt; a.getResource() == Resource.Blocked);</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method returns a card given the coordinates of its position.
&nbsp;     *
&nbsp;     * @param x The row of the position.
&nbsp;     * @param y The column of the position.
&nbsp;     * @return PlaceableCard The card at the given position. If no card exists at the given position, it returns null.
&nbsp;     */
&nbsp;    private PlaceableCard getCard(int x, int y) {
&nbsp;        /*
&nbsp;          There are two candidates for the return: the topCard and the bottomCard
&nbsp;          in the cell at coordinates (x,y)
&nbsp;         */
<b class="fc">&nbsp;        Cell cell = getCell(x, y);</b>
<b class="fc">&nbsp;        if (cell == null)</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;
<b class="fc">&nbsp;        PlaceableCard topCard = cell.getTopCard();</b>
<b class="fc">&nbsp;        PlaceableCard bottomCard = cell.getBottomCard();</b>
&nbsp;
<b class="fc">&nbsp;        if (topCard != null</b>
<b class="fc">&nbsp;                &amp;&amp; topCard.getCells().getFirst().getRow() == cell.getRow()</b>
<b class="fc">&nbsp;                &amp;&amp; topCard.getCells().getFirst().getColumn() == cell.getColumn())</b>
<b class="fc">&nbsp;            return topCard;</b>
&nbsp;
&nbsp;
<b class="pc">&nbsp;        if (bottomCard != null</b>
<b class="fc">&nbsp;                &amp;&amp; bottomCard.getCells().getFirst().getRow() == cell.getRow()</b>
<b class="fc">&nbsp;                &amp;&amp; bottomCard.getCells().getFirst().getColumn() == cell.getColumn())</b>
<b class="fc">&nbsp;            return bottomCard;</b>
&nbsp;
<b class="fc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method places the starter card in the player&#39;s area.
&nbsp;     *
&nbsp;     * @param card  The starter card to place.
&nbsp;     * @param front The side of the starter card to place.
&nbsp;     */
&nbsp;    public void placeStarterCard(PlaceableCard card, boolean front) {
<b class="fc">&nbsp;        card.setFront(front);</b>
<b class="fc">&nbsp;        card.getPermanentResource().forEach(this::addPermanentResource);</b>
<b class="fc">&nbsp;        ArrayList&lt;Cell&gt; cells = new ArrayList&lt;&gt;();</b>
&nbsp;        //the starterCard will be placed at coordinates (0,0)
<b class="fc">&nbsp;        cells.add(new Cell(0, 0, card));</b>
<b class="fc">&nbsp;        cells.add(new Cell(0, 1, card));</b>
<b class="fc">&nbsp;        cells.add(new Cell(1, 0, card));</b>
<b class="fc">&nbsp;        cells.add(new Cell(1, 1, card));</b>
<b class="fc">&nbsp;        card.setCells(cells);</b>
<b class="fc">&nbsp;        cells.forEach(this::addCell);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method places a card in the player&#39;s area.
&nbsp;     *
&nbsp;     * @param card Reference to the card to place
&nbsp;     * @param x    Row coordinate
&nbsp;     * @param y    Column coordinate
&nbsp;     * @return Points given by the placement of the card
&nbsp;     * @throws noPlaceCardException If in the given position a card cannot be placed
&nbsp;     */
&nbsp;    public int placeCard(PlaceableCard card, int x, int y, boolean front) throws noPlaceCardException {
&nbsp;        // checks if the position is available
<b class="fc">&nbsp;        if (!checkPosition(x, y))</b>
<b class="fc">&nbsp;            throw new noPlaceCardException();</b>
&nbsp;
&nbsp;
<b class="fc">&nbsp;        int points = 0;</b>
&nbsp;
&nbsp;        /*
&nbsp;          The cells to check are:
&nbsp;          (x  , y  )
&nbsp;          (x  , y+1)
&nbsp;          (x+1, y  )
&nbsp;          (x+1, y+1)
&nbsp;         */
&nbsp;        //Obtain the existing cells
<b class="fc">&nbsp;        ArrayList&lt;Cell&gt; position = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        position.add(getCell(x, y));</b>
<b class="fc">&nbsp;        position.add(getCell(x, y + 1));</b>
<b class="fc">&nbsp;        position.add(getCell(x + 1, y));</b>
<b class="fc">&nbsp;        position.add(getCell(x + 1, y + 1));</b>
&nbsp;
&nbsp;        //setting front or back
<b class="fc">&nbsp;        card.setFront(front);</b>
&nbsp;
&nbsp;        // obtaining points
<b class="fc">&nbsp;        if (front) {</b>
<b class="fc">&nbsp;            if (!card.checkRequirement(this.getResources()))</b>
<b class="fc">&nbsp;                throw new noPlaceCardException();</b>
&nbsp;            else {
<b class="fc">&nbsp;                ArrayList&lt;Integer&gt; pointsOnResource = new ArrayList&lt;&gt;(); //contains the id of the cards that give points if playerArea contains the requested resource</b>
<b class="fc">&nbsp;                ArrayList&lt;Integer&gt; pointsOnCorner = new ArrayList&lt;&gt;(); //contains the id of the cards that give points for each corner of cards in playerArea covered when the card is placed</b>
&nbsp;                //FUNGUS
<b class="fc">&nbsp;                pointsOnResource.add(41);</b>
<b class="fc">&nbsp;                pointsOnResource.add(42);</b>
<b class="fc">&nbsp;                pointsOnResource.add(43);</b>
<b class="fc">&nbsp;                pointsOnCorner.add(44);</b>
<b class="fc">&nbsp;                pointsOnCorner.add(45);</b>
<b class="fc">&nbsp;                pointsOnCorner.add(46);</b>
&nbsp;
&nbsp;                //PLANT
<b class="fc">&nbsp;                pointsOnResource.add(51);</b>
<b class="fc">&nbsp;                pointsOnResource.add(52);</b>
<b class="fc">&nbsp;                pointsOnResource.add(53);</b>
<b class="fc">&nbsp;                pointsOnCorner.add(54);</b>
<b class="fc">&nbsp;                pointsOnCorner.add(55);</b>
<b class="fc">&nbsp;                pointsOnCorner.add(56);</b>
&nbsp;
&nbsp;                //ANIMAL
<b class="fc">&nbsp;                pointsOnResource.add(61);</b>
<b class="fc">&nbsp;                pointsOnResource.add(62);</b>
<b class="fc">&nbsp;                pointsOnResource.add(63);</b>
<b class="fc">&nbsp;                pointsOnCorner.add(64);</b>
<b class="fc">&nbsp;                pointsOnCorner.add(65);</b>
<b class="fc">&nbsp;                pointsOnCorner.add(66);</b>
&nbsp;
&nbsp;                //INSECT
<b class="fc">&nbsp;                pointsOnResource.add(71);</b>
<b class="fc">&nbsp;                pointsOnResource.add(72);</b>
<b class="fc">&nbsp;                pointsOnResource.add(73);</b>
<b class="fc">&nbsp;                pointsOnCorner.add(74);</b>
<b class="fc">&nbsp;                pointsOnCorner.add(75);</b>
<b class="fc">&nbsp;                pointsOnCorner.add(76);</b>
&nbsp;
&nbsp;
<b class="fc">&nbsp;                if (pointsOnResource.contains(card.getID())) {</b>
&nbsp;                    //ArrayList&lt;Integer&gt; resource = this.getResources();
&nbsp;                    //counts the number of cells, excluded the ones contained in position, that posses the requested resource
&nbsp;                    // Quill
<b class="pc">&nbsp;                    if (card.getID() == 41 || card.getID() == 51 || card.getID() == 63 || card.getID() == 71) {</b>
<b class="nc">&nbsp;                        points = (int) (1 + CellMatrix.values().stream()</b>
<b class="nc">&nbsp;                                .filter(cell -&gt; !position.contains(cell))</b>
<b class="nc">&nbsp;                                .filter(cell -&gt; cell.getResource() == Resource.Quill)</b>
<b class="nc">&nbsp;                                .count());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // Inkwell
<b class="pc">&nbsp;                    if (card.getID() == 42 || card.getID() == 53 || card.getID() == 61 || card.getID() == 73) {</b>
<b class="nc">&nbsp;                        points = (int) (1 + CellMatrix.values().stream()</b>
<b class="nc">&nbsp;                                .filter(cell -&gt; !position.contains(cell))</b>
<b class="nc">&nbsp;                                .filter(cell -&gt; cell.getResource() == Resource.Inkwell)</b>
<b class="nc">&nbsp;                                .count());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // Manuscript
<b class="pc">&nbsp;                    if (card.getID() == 43 || card.getID() == 52 || card.getID() == 62 || card.getID() == 72) {</b>
<b class="fc">&nbsp;                        points = (int) (1 + CellMatrix.values().stream()</b>
<b class="fc">&nbsp;                                .filter(cell -&gt; !position.contains(cell))</b>
<b class="pc">&nbsp;                                .filter(cell -&gt; cell.getResource() == Resource.Manuscript)</b>
<b class="fc">&nbsp;                                .count());</b>
&nbsp;                    }
&nbsp;
&nbsp;
<b class="fc">&nbsp;                } else if (pointsOnCorner.contains(card.getID())) {</b>
&nbsp;                    //counts the number of cells in position that already have a reference to a bottom card
<b class="fc">&nbsp;                    points = (int) (2 * position.stream()</b>
<b class="fc">&nbsp;                            .filter(Objects::nonNull) //now the stream contains only the cells of position that are not null</b>
<b class="fc">&nbsp;                            .count());</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    points = card.getPoints();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        //Setting up the new positions
<b class="fc">&nbsp;        for (int i = 0; i &lt; position.size(); i++) {</b>
<b class="fc">&nbsp;            if (position.get(i) != null) {</b>
&nbsp;                //if cell at index i is not null it means the cell is already present in CellMatrix, so we set its topCard reference to the card placed
<b class="fc">&nbsp;                position.get(i).linkCard(card);</b>
&nbsp;
&nbsp;            } else {
<b class="fc">&nbsp;                int ro = 0;</b>
<b class="pc">&nbsp;                int co = switch (i) {</b>
&nbsp;                    case 0 -&gt; {
<b class="fc">&nbsp;                        ro = x;</b>
<b class="fc">&nbsp;                        yield y;</b>
&nbsp;                    }
&nbsp;                    case 1 -&gt; {
<b class="fc">&nbsp;                        ro = x;</b>
<b class="fc">&nbsp;                        yield y + 1;</b>
&nbsp;                    }
&nbsp;                    case 2 -&gt; {
<b class="fc">&nbsp;                        ro = x + 1;</b>
<b class="fc">&nbsp;                        yield y;</b>
&nbsp;                    }
&nbsp;                    case 3 -&gt; {
<b class="fc">&nbsp;                        ro = x + 1;</b>
<b class="fc">&nbsp;                        yield y + 1;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    default -&gt; y;</b>
<b class="fc">&nbsp;                };</b>
<b class="fc">&nbsp;                Cell tmpCell = new Cell(ro, co, card); //creates new cell with card as bottomCard</b>
<b class="fc">&nbsp;                this.addCell(tmpCell); //adds the cell to CellMatrix</b>
<b class="fc">&nbsp;                position.set(i, tmpCell); //adds the cell to position</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        card.setCells(position); //the cells in position are set as the cells of the card</b>
&nbsp;
&nbsp;        // Eventually adds the permanent resources
<b class="fc">&nbsp;        card.getPermanentResource().forEach(this::addPermanentResource);</b>
&nbsp;
<b class="fc">&nbsp;        return points;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a sorted list of all cards: first the card on top and on the left
&nbsp;     *
&nbsp;     * @return Ordered list of all cards
&nbsp;     */
&nbsp;    public ArrayList&lt;PlaceableCard&gt; getAllCards() {
<b class="fc">&nbsp;        return CellMatrix.values().stream()</b>
<b class="fc">&nbsp;                .flatMap(cell -&gt; Stream.of(cell.getBottomCard(), cell.getTopCard()))</b>
<b class="fc">&nbsp;                .filter(Objects::nonNull) //now the stream contains only PlaceableCard that are not null</b>
<b class="fc">&nbsp;                .distinct()</b>
<b class="fc">&nbsp;                .sorted(Comparator.comparing((PlaceableCard card) -&gt; card.getCells().getFirst().getRow())</b>
<b class="fc">&nbsp;                        .thenComparing(card -&gt; card.getCells().getFirst().getColumn()))</b>
<b class="fc">&nbsp;                .collect(Collectors.toCollection(ArrayList::new));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check if there are pattern of the given ID
&nbsp;     *
&nbsp;     * @param card Reference to the objective to identify
&nbsp;     * @return Number of points generated by the patterns
&nbsp;     */
&nbsp;    public int checkPattern(ObjectiveCard card) {
<b class="fc">&nbsp;        HashSet&lt;PlaceableCard&gt; checkedCards = new HashSet&lt;&gt;();</b>
&nbsp;        ArrayList&lt;PlaceableCard&gt; allCards;
<b class="fc">&nbsp;        int points = 0;</b>
&nbsp;
<b class="pc">&nbsp;        if (card == null)</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;
<b class="pc">&nbsp;        if (card.getPattern() != null &amp;&amp; !card.getPattern().isEmpty()) {</b>
<b class="fc">&nbsp;            allCards = getAllCards();</b>
<b class="fc">&nbsp;            ArrayList&lt;int[]&gt; pattern = card.getPattern(); //ArrayList of arrays that contains the relative positions of the other cards from the objective card</b>
<b class="fc">&nbsp;            ArrayList&lt;Reign&gt; reigns = card.getReignCards(); //ArrayList that contains the reigns the cards involved in the pattern must belong</b>
<b class="fc">&nbsp;            for (PlaceableCard card0 : allCards) {</b>
<b class="fc">&nbsp;                if (!checkedCards.contains(card0) &amp;&amp; card0.getReign() != null &amp;&amp; card0.getReign().equals(reigns.getFirst())) {</b>
<b class="fc">&nbsp;                    int row = card0.getCells().getFirst().getRow();</b>
<b class="fc">&nbsp;                    int column = card0.getCells().getFirst().getColumn();</b>
&nbsp;                    //we obtain card1 and card2 adding to row and column of the considered card the relative positions required by the card&#39;s pattern
<b class="fc">&nbsp;                    PlaceableCard card1 = this.getCard(row + pattern.get(0)[0], column + pattern.get(0)[1]);</b>
<b class="fc">&nbsp;                    PlaceableCard card2 = this.getCard(row + pattern.get(1)[0], column + pattern.get(1)[1]);</b>
&nbsp;
<b class="fc">&nbsp;                    if (card1 != null &amp;&amp; card2 != null</b>
<b class="pc">&nbsp;                            &amp;&amp; card1.getReign() != null &amp;&amp; card2.getReign() != null</b>
<b class="pc">&nbsp;                            &amp;&amp; card1.getReign() == reigns.get(1) &amp;&amp; card2.getReign() == reigns.get(2)</b>
<b class="pc">&nbsp;                            &amp;&amp; !checkedCards.contains(card1) &amp;&amp; !checkedCards.contains(card2)) {</b>
<b class="fc">&nbsp;                        points = points + card.getPoints();</b>
<b class="fc">&nbsp;                        checkedCards.add(card0);</b>
<b class="fc">&nbsp;                        checkedCards.add(card1);</b>
<b class="fc">&nbsp;                        checkedCards.add(card2);</b>
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            return points;</b>
&nbsp;        }
&nbsp;
<b class="pc">&nbsp;        if (card.getRequirements() != null &amp;&amp; !card.getRequirements().isEmpty()) {</b>
<b class="fc">&nbsp;            ArrayList&lt;Resource&gt; requirements = card.getRequirements();</b>
<b class="fc">&nbsp;            ArrayList&lt;Integer&gt; resources = this.getResources();</b>
&nbsp;
<b class="pc">&nbsp;            if (requirements.stream().distinct().count() == 1) {</b>
&nbsp;                //the card requires to possess a number of the same resource
<b class="pc">&nbsp;                int index = switch (requirements.getFirst()) {</b>
<b class="fc">&nbsp;                    case Fungus -&gt; 0;</b>
<b class="nc">&nbsp;                    case Insect -&gt; 1;</b>
<b class="nc">&nbsp;                    case Animal -&gt; 2;</b>
<b class="fc">&nbsp;                    case Plant -&gt; 3;</b>
<b class="nc">&nbsp;                    case Manuscript -&gt; 4;</b>
<b class="nc">&nbsp;                    case Quill -&gt; 5;</b>
<b class="nc">&nbsp;                    case Inkwell -&gt; 6;</b>
<b class="nc">&nbsp;                    case Empty -&gt; 7;</b>
<b class="nc">&nbsp;                    case Blocked -&gt; 8;</b>
&nbsp;                };
&nbsp;
<b class="pc">&nbsp;                if (index &lt; 4)</b>
<b class="fc">&nbsp;                    points = card.getPoints() * (resources.get(index) / 3); //the points of the card are multiplied by the number of times the playerArea contains 3 resources required</b>
&nbsp;                else
<b class="nc">&nbsp;                    points = card.getPoints() * (resources.get(index) / 2);</b>
<b class="fc">&nbsp;                return points;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (card.getID() == 99) {</b>
&nbsp;                //the card require to possess a manuscript, a quill and an inkwell
<b class="nc">&nbsp;                if (resources.get(4) &lt; resources.get(5)) {</b>
&nbsp;                    //the number of manuscript is smaller than the number of quill
<b class="nc">&nbsp;                    if (resources.get(4) &lt; resources.get(6))</b>
<b class="nc">&nbsp;                        return 3 * resources.get(4);</b>
&nbsp;                    else
<b class="nc">&nbsp;                        return 3 * resources.get(6);</b>
&nbsp;                } else { //the number of manuscript is bigger than the number of quill
<b class="nc">&nbsp;                    if (resources.get(5) &lt; resources.get(6))</b>
<b class="nc">&nbsp;                        return 3 * resources.get(5);</b>
&nbsp;                    else
<b class="nc">&nbsp;                        return 3 * resources.get(6);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return points;</b>
&nbsp;        }
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Counts the number of times a pattern is achieved
&nbsp;     *
&nbsp;     * @param card Identifies the pattern to search for
&nbsp;     * @return number of times a pattern is encountered
&nbsp;     */
&nbsp;    public int countPattern(ObjectiveCard card) {
<b class="fc">&nbsp;        return this.checkPattern(card) / card.getPoints();</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-06-26 22:00</div>
</div>
</body>
</html>
