


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Client</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">it.polimi.ingsw.client</a>
</div>

<h1>Coverage Summary for Class: Client (it.polimi.ingsw.client)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Client</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/66)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/194)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;    package it.polimi.ingsw.client;
&nbsp;
&nbsp;    import it.polimi.ingsw.client.controller.Controller;
&nbsp;    import it.polimi.ingsw.client.controller.ControllerRMI;
&nbsp;    import it.polimi.ingsw.client.controller.ControllerSocket;
&nbsp;    import it.polimi.ingsw.client.view.View;
&nbsp;    import it.polimi.ingsw.client.view.ViewCLI;
&nbsp;    import it.polimi.ingsw.messages.connectionState.availableColorsMessage;
&nbsp;    import it.polimi.ingsw.messages.connectionState.connectionResponseMessage;
&nbsp;    import it.polimi.ingsw.messages.connectionState.unavailableNamesMessage;
&nbsp;    import it.polimi.ingsw.messages.currentStateMessage;
&nbsp;    import it.polimi.ingsw.messages.endGameState.declareWinnerMessage;
&nbsp;    import it.polimi.ingsw.messages.playerTurnState.updatePlayerMessage;
&nbsp;    import it.polimi.ingsw.messages.responseMessage;
&nbsp;    import it.polimi.ingsw.messages.serverOptionState.serverOptionMessage;
&nbsp;    import it.polimi.ingsw.messages.waitingForPlayerState.newHostMessage;
&nbsp;    import it.polimi.ingsw.model.cards.ObjectiveCard;
&nbsp;
&nbsp;    import java.util.ArrayList;
&nbsp;    import java.util.Objects;
&nbsp;    import java.util.concurrent.*;
&nbsp;    import java.util.concurrent.atomic.AtomicBoolean;
&nbsp;    import java.util.concurrent.atomic.AtomicIntegerArray;
&nbsp;/**
&nbsp; * This class is the Client class.
&nbsp; * It is responsible for the client side of the application.
&nbsp; * It is responsible for the connection to the server and the communication with it.
&nbsp; */
&nbsp;public class Client implements Runnable {
&nbsp;    private final View view;
&nbsp;    private final ThreadPoolExecutor executor;
&nbsp;    //initializes a default value, the methods of the view will return this value in case the user does not provide an answer in time
<b class="nc">&nbsp;    private final Integer defaultValue = 1000;</b>
&nbsp;    private String serverIP;
&nbsp;    private Controller controller;
&nbsp;    private int timeout;
&nbsp;
&nbsp;    /**
&nbsp;     * method {@code Client}: Constructor for the Client class
&nbsp;     *
&nbsp;     * @param view view of the client
&nbsp;     */
<b class="nc">&nbsp;    public Client(View view) {</b>
<b class="nc">&nbsp;        timeout = 120;</b>
<b class="nc">&nbsp;        this.view = view;</b>
<b class="nc">&nbsp;        int corePoolSize = 5;</b>
<b class="nc">&nbsp;        int maximumPoolSize = 200;</b>
<b class="nc">&nbsp;        long keepAliveTime = 300;</b>
<b class="nc">&nbsp;        TimeUnit unit = TimeUnit.SECONDS;</b>
<b class="nc">&nbsp;        executor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, new LinkedBlockingQueue&lt;&gt;());</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * method {@code getController}: Getter for the controller
&nbsp;     *
&nbsp;     * @return the controller
&nbsp;     */
&nbsp;    private Controller getController() {
<b class="nc">&nbsp;        return controller;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * method {@code getView}: Getter for the view
&nbsp;     *
&nbsp;     * @return the view
&nbsp;     */
&nbsp;    private View getView() {
<b class="nc">&nbsp;        return view;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * method {@code connection}: sets socket or rmi. Enables GUI or CLI.
&nbsp;     * Connects to a socket server or rmi server.
&nbsp;     */
&nbsp;    private void connection(boolean isSocket) {
&nbsp;
<b class="nc">&nbsp;        if (isSocket) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                controller.connectToServer(serverIP, &quot;1024&quot;);</b>
<b class="nc">&nbsp;                connectionResponseMessage answer = controller.answerConnection();</b>
<b class="nc">&nbsp;                if (view instanceof ViewCLI)</b>
<b class="nc">&nbsp;                    ((ViewCLI) view).answerToConnection(answer);</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                view.playerDisconnected(e);</b>
<b class="nc">&nbsp;                throw new RuntimeException();</b>
&nbsp;            }
&nbsp;        } else {
&nbsp;            try {
<b class="nc">&nbsp;                controller.connectToServer(serverIP, &quot;1099&quot;);</b>
<b class="nc">&nbsp;                connectionResponseMessage answer = controller.answerConnection();</b>
<b class="nc">&nbsp;                if (view instanceof ViewCLI)</b>
<b class="nc">&nbsp;                    ((ViewCLI) view).answerToConnection(answer);</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                view.playerDisconnected(e);</b>
<b class="nc">&nbsp;                throw new RuntimeException();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * method {@code serverOptions}: invocations of controller methods to send and receive serverOptionMessage.
&nbsp;     * Invocations of view methods to display options and receive user&#39;s choices.
&nbsp;     * invocations of controller methods to receive responseMessage. If responseMessage is correct, the loop ends.
&nbsp;     */
&nbsp;    private void serverOptions() {
&nbsp;        while (true) {
<b class="nc">&nbsp;            serverOptionMessage options = controller.serverOptions();</b>
&nbsp;            //options = view.serverOptions(options);
<b class="nc">&nbsp;            serverOptionMessage finalOptions = options;</b>
&nbsp;
<b class="nc">&nbsp;            Future&lt;serverOptionMessage&gt; future = executor.submit(() -&gt; view.serverOptions(finalOptions));</b>
&nbsp;            try {
<b class="nc">&nbsp;                options = future.get(timeout, TimeUnit.SECONDS);</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                future.cancel(true);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            controller.sendOptions(options);</b>
<b class="nc">&nbsp;            responseMessage answer = controller.correctAnswer();</b>
&nbsp;
<b class="nc">&nbsp;            boolean ok = false;</b>
<b class="nc">&nbsp;            while (!ok)</b>
<b class="nc">&nbsp;                ok = view.answer(answer);</b>
&nbsp;
<b class="nc">&nbsp;            if (answer.getCorrect())</b>
&nbsp;                break; //breaks the cycle if server received valid values
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * method {@code name}: invocations of controller methods to receive unavailableNamesMessage.
&nbsp;     * Invocations of view methods to display unavailable names and receive name chosen.
&nbsp;     * invocations of controller methods to send received info.
&nbsp;     * invocations of controller methods to receive responseMessage. If responseMessage is correct, the loop ends.
&nbsp;     */
&nbsp;    private void name() {
&nbsp;        //in case the cli user does not provide an answer (only press enter), name is set to &quot; &quot;
&nbsp;        //the loop will repeat until server receive a valid value
&nbsp;        while (true) {
<b class="nc">&nbsp;            unavailableNamesMessage unavailableName = controller.getUnavailableName();</b>
&nbsp;
&nbsp;            String name;
<b class="nc">&nbsp;            Future&lt;String&gt; future = executor.submit(() -&gt; view.unavailableNames(unavailableName));</b>
&nbsp;            try {
<b class="nc">&nbsp;                name = future.get(timeout, TimeUnit.SECONDS);</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                future.cancel(true);</b>
<b class="nc">&nbsp;                name = &quot;&quot;;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            controller.chooseName(name);</b>
<b class="nc">&nbsp;            responseMessage answer = controller.correctAnswer();</b>
&nbsp;
<b class="nc">&nbsp;            boolean ok = false;</b>
<b class="nc">&nbsp;            while (!ok)</b>
<b class="nc">&nbsp;                ok = view.answer(answer);</b>
&nbsp;
<b class="nc">&nbsp;            if (answer.getCorrect())</b>
&nbsp;                break;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * method {@code color}: invocations of controller methods to receive availableColorsMessage.
&nbsp;     * Invocations of view methods to display available colors and receive user&#39;s choice.
&nbsp;     * invocations of controller methods to send received info.
&nbsp;     * invocations of controller methods to receive responseMessage. If responseMessage is correct, the loop ends.
&nbsp;     */
&nbsp;    private void color() {
&nbsp;        while (true) {
<b class="nc">&nbsp;            availableColorsMessage availableColor = controller.getAvailableColor();</b>
&nbsp;            //String color = view.availableColors(availableColor);
&nbsp;            String color;
<b class="nc">&nbsp;            Future&lt;String&gt; future = executor.submit(() -&gt; view.availableColors(availableColor));</b>
&nbsp;            try {
<b class="nc">&nbsp;                color = future.get(timeout, TimeUnit.SECONDS);</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                future.cancel(true);</b>
<b class="nc">&nbsp;                color = &quot;&quot;;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            controller.chooseColor(color);</b>
<b class="nc">&nbsp;            responseMessage answer = controller.correctAnswer();</b>
&nbsp;
<b class="nc">&nbsp;            boolean ok = false;</b>
<b class="nc">&nbsp;            while (!ok)</b>
<b class="nc">&nbsp;                ok = view.answer(answer);</b>
&nbsp;
<b class="nc">&nbsp;            if (answer.getCorrect())</b>
&nbsp;                break;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invocations of view methods to ask and receive from host the number of expected player.
&nbsp;     * invocations of controller methods to send received info.
&nbsp;     * invocations of controller methods to receive responseMessage. If responseMessage is correct, the loop ends.
&nbsp;     */
&nbsp;    private void waitingPlayer(currentStateMessage current) {
&nbsp;        Integer expected;
<b class="nc">&nbsp;        AtomicBoolean noResponse = new AtomicBoolean(false);</b>
&nbsp;
<b class="nc">&nbsp;        newHostMessage newHost = controller.newHost();</b>
&nbsp;
<b class="nc">&nbsp;        while (Objects.equals(newHost.getNewHostNickname(), current.getPlayer().getNickname())) {</b>
&nbsp;            //if the method expectedPlayers is not computed in time or user provide no answer, noResponse will be set to true
<b class="nc">&nbsp;            expected = getFutureResult(view::expectedPlayers, noResponse);</b>
&nbsp;
<b class="nc">&nbsp;            controller.expectedPlayers(expected, noResponse.get());</b>
<b class="nc">&nbsp;            responseMessage answer = controller.correctAnswer();</b>
&nbsp;
<b class="nc">&nbsp;            boolean ok = false;</b>
<b class="nc">&nbsp;            while (!ok)</b>
<b class="nc">&nbsp;                ok = view.answer(answer);</b>
&nbsp;
<b class="nc">&nbsp;            if (answer.getCorrect()) {</b>
<b class="nc">&nbsp;                view.waiting();</b>
&nbsp;                break;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * method {@code starter}: invocations of controller methods to receive and send messages.
&nbsp;     * Invocations of view methods to display and receive player&#39;s info.
&nbsp;     * invocations of controller methods to send received info.
&nbsp;     * invocations of controller methods to receive responseMessage. If responseMessage is correct, the loop ends.
&nbsp;     */
&nbsp;    private void starter() {
&nbsp;        Integer side;
<b class="nc">&nbsp;        AtomicBoolean noResponse = new AtomicBoolean(false);</b>
&nbsp;
&nbsp;        while (true) {
<b class="nc">&nbsp;            side = getFutureResult(view::placeStarter, noResponse);</b>
&nbsp;
<b class="nc">&nbsp;            controller.placeStarter(side, noResponse.get());</b>
<b class="nc">&nbsp;            responseMessage answer = controller.correctAnswer();</b>
&nbsp;
&nbsp;
<b class="nc">&nbsp;            boolean ok = false;</b>
<b class="nc">&nbsp;            while (!ok)</b>
<b class="nc">&nbsp;                ok = view.answer(answer);</b>
&nbsp;
<b class="nc">&nbsp;            if (answer.getCorrect())</b>
&nbsp;                break;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * method {@code pickObjective}: invocations of controller methods to receive and send messages.
&nbsp;     * Invocations of view methods to display and receive player&#39;s info.
&nbsp;     * invocations of controller methods to send received info.
&nbsp;     * invocations of controller methods to receive responseMessage. If responseMessage is correct, the loop ends.
&nbsp;     */
&nbsp;    private void pickObjective() {
&nbsp;        Integer pick;
<b class="nc">&nbsp;        boolean noResponse = false;</b>
&nbsp;
&nbsp;
&nbsp;        while (true) {
<b class="nc">&nbsp;            ArrayList&lt;ObjectiveCard&gt; objectives = controller.getObjectiveCards().getObjectiveCard();</b>
&nbsp;
<b class="nc">&nbsp;            Future&lt;Integer&gt; future = executor.submit(() -&gt; view.chooseObjective(objectives));</b>
&nbsp;
&nbsp;            try {
<b class="nc">&nbsp;                pick = future.get(timeout, TimeUnit.SECONDS);</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                future.cancel(true);</b>
<b class="nc">&nbsp;                pick = defaultValue;</b>
<b class="nc">&nbsp;                noResponse = true;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            controller.chooseObjective(pick, noResponse);</b>
<b class="nc">&nbsp;            responseMessage answer = controller.correctAnswer();</b>
&nbsp;
<b class="nc">&nbsp;            boolean ok = false;</b>
<b class="nc">&nbsp;            while (!ok)</b>
<b class="nc">&nbsp;                ok = view.answer(answer);</b>
&nbsp;
<b class="nc">&nbsp;            if (answer.getCorrect())</b>
&nbsp;                break;
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * method {@code pickCard}: invocations of controller methods to receive and send messages.
&nbsp;     * Invocations of view methods to display and receive player&#39;s info.
&nbsp;     * invocations of controller methods to send received info.
&nbsp;     * invocations of controller methods to receive responseMessage. If responseMessage is correct, the loop ends.
&nbsp;     */
&nbsp;    private void pickCard() {
&nbsp;        Integer card;
<b class="nc">&nbsp;        AtomicBoolean noResponse = new AtomicBoolean(false);</b>
&nbsp;
&nbsp;        while (true) {
<b class="nc">&nbsp;            card = getFutureResult(view::pickCard, noResponse);</b>
&nbsp;
&nbsp;
<b class="nc">&nbsp;            controller.pickCard(card, noResponse.get());</b>
<b class="nc">&nbsp;            responseMessage answer = controller.correctAnswer();</b>
&nbsp;
<b class="nc">&nbsp;            boolean ok = false;</b>
<b class="nc">&nbsp;            while (!ok)</b>
<b class="nc">&nbsp;                ok = view.answer(answer);</b>
&nbsp;
<b class="nc">&nbsp;            if (answer.getCorrect())</b>
&nbsp;                break;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * method {@code getFutureResult}: gets the result of a future task.
&nbsp;     *
&nbsp;     * @param task:       Callable&lt;T&gt;
&nbsp;     * @param noResponse: AtomicBoolean
&nbsp;     * @return the result of the future task or the default value
&nbsp;     */
&nbsp;    private &lt;T&gt; T getFutureResult(Callable&lt;T&gt; task, AtomicBoolean noResponse) {
<b class="nc">&nbsp;        Future&lt;T&gt; future = executor.submit(task);</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            return future.get(timeout, TimeUnit.SECONDS);</b>
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            future.cancel(true);</b>
<b class="nc">&nbsp;            noResponse.set(true); // Update the noResponse flag</b>
<b class="nc">&nbsp;            return (T) defaultValue;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;//    /**
&nbsp;//     *
&nbsp;//     * @param task: Callable&lt;Integer&gt;, the result of the task will be an Integer
&nbsp;//     * @param noResponse: AtomicBoolean
&nbsp;//     * @return the result of the future task or defaultValue
&nbsp;//     */
&nbsp;//     Alternative: in this class we use this method submitting to the executor view.pickCard, view.expectedPlayers, view.placeStarter
&nbsp;//     they all return an int value so there is no need use a generic value &lt;T&gt;
&nbsp;//    private Integer getFutureResult(Callable&lt;Integer&gt; task, AtomicBoolean noResponse) {
&nbsp;//        Future&lt;Integer&gt; future = executor.submit(task);
&nbsp;//        Integer valueToReturn;
&nbsp;//        try {
&nbsp;//            valueToReturn = future.get(120, TimeUnit.SECONDS);
&nbsp;//            return valueToReturn;
&nbsp;//        } catch (Exception e) {
&nbsp;//            //if the computation of the task is not completed within 2 minutes noResponse is set to true,
&nbsp;//            // and we return the default value
&nbsp;//            future.cancel(true);
&nbsp;//            noResponse.set(true); // Update the noResponse flag
&nbsp;//            return defaultValue;
&nbsp;//        }
&nbsp;//    }
&nbsp;
&nbsp;    /**
&nbsp;     * method {@code placeCard}: invocations of controller methods to receive and send messages.
&nbsp;     * Invocations of view methods to display and receive player&#39;s info.
&nbsp;     * invocations of controller methods to send received info.
&nbsp;     * invocations of controller methods to receive responseMessage. If responseMessage is correct, the loop ends.
&nbsp;     */
&nbsp;    private void placeCard() {
<b class="nc">&nbsp;        AtomicIntegerArray card = new AtomicIntegerArray(4);</b>
<b class="nc">&nbsp;        boolean noResponse = false;</b>
&nbsp;
&nbsp;        while (true) {
<b class="nc">&nbsp;            Future&lt;int[]&gt; future = executor.submit(view::placeCard);</b>
&nbsp;            //we wait two minutes to obtain the result of the submitted task
&nbsp;            //then if computation is not completed an exception is thrown, noResponse is set to true, user&#39;s choices are set to default value
&nbsp;            try {
<b class="nc">&nbsp;                int[] cardArray = future.get(timeout, TimeUnit.SECONDS);</b>
<b class="nc">&nbsp;                card.set(0, cardArray[0]);</b>
<b class="nc">&nbsp;                card.set(1, cardArray[1]);</b>
<b class="nc">&nbsp;                card.set(2, cardArray[2]);</b>
<b class="nc">&nbsp;                card.set(3, cardArray[3]);</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                future.cancel(true);</b>
<b class="nc">&nbsp;                card.set(0, defaultValue);</b>
<b class="nc">&nbsp;                card.set(1, defaultValue);</b>
<b class="nc">&nbsp;                card.set(2, defaultValue);</b>
<b class="nc">&nbsp;                card.set(3, defaultValue);</b>
<b class="nc">&nbsp;                noResponse = true;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            controller.placeCard(card.get(0), card.get(1), card.get(2), card.get(3), noResponse);</b>
<b class="nc">&nbsp;            responseMessage answer = controller.correctAnswer();</b>
&nbsp;
<b class="nc">&nbsp;            boolean ok = false;</b>
<b class="nc">&nbsp;            while (!ok)</b>
<b class="nc">&nbsp;                ok = view.answer(answer);</b>
&nbsp;
<b class="nc">&nbsp;            if (answer.getCorrect())</b>
&nbsp;                break;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * method {@code setIP}: sets serverIP
&nbsp;     *
&nbsp;     * @param serverIP: String
&nbsp;     */
&nbsp;    private void setIP(String serverIP) {
<b class="nc">&nbsp;        this.serverIP = serverIP;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * method {@code setController}: sets the Controller
&nbsp;     *
&nbsp;     * @param server:   String[]
&nbsp;     * @param isSocket: boolean
&nbsp;     */
&nbsp;    private void setController(String server, boolean isSocket) {
<b class="nc">&nbsp;        if (isSocket) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                this.controller = new ControllerSocket(server, &quot;1024&quot;);</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                view.playerDisconnected(e);</b>
&nbsp;            }
&nbsp;        } else {
&nbsp;            try {
<b class="nc">&nbsp;                this.controller = new ControllerRMI(server, &quot;1099&quot;);</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                view.playerDisconnected(e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * method {@code pickNameFA}: invocations of controller methods to receive and send messages.
&nbsp;     * Invocations of view methods to display and receive player&#39;s info.
&nbsp;     * Asks the player to pick a name between the available ones.
&nbsp;     */
&nbsp;    private void pickNameFA() {
&nbsp;        String name;
&nbsp;
&nbsp;        while (true) {
<b class="nc">&nbsp;            unavailableNamesMessage unavailableName = controller.getUnavailableName();</b>
<b class="nc">&nbsp;            Future&lt;String&gt; future = executor.submit(() -&gt; view.pickNameFA(unavailableName));</b>
&nbsp;
&nbsp;            try {
<b class="nc">&nbsp;                name = future.get(timeout, TimeUnit.SECONDS);</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                future.cancel(true);</b>
<b class="nc">&nbsp;                name = &quot;defaultName&quot;;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            controller.chooseName(name);</b>
<b class="nc">&nbsp;            responseMessage answer = controller.correctAnswer();</b>
&nbsp;
<b class="nc">&nbsp;            boolean ok = false;</b>
<b class="nc">&nbsp;            while (!ok)</b>
<b class="nc">&nbsp;                ok = view.answer(answer);</b>
&nbsp;
<b class="nc">&nbsp;            if (answer.getCorrect())</b>
&nbsp;                break;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * method {@code whileRun}: main loop of the client
&nbsp;     * Invocations of controller methods to receive and send messages.
&nbsp;     * Invocations of view methods to display and receive player&#39;s info.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void run() {
&nbsp;
<b class="nc">&nbsp;        boolean ok = false;</b>
<b class="nc">&nbsp;        while (!ok)</b>
<b class="nc">&nbsp;            ok = getView().startMain();</b>
&nbsp;
&nbsp;
&nbsp;        while (true) {
&nbsp;            try {
<b class="nc">&nbsp;                String server = getView().askIP();</b>
<b class="nc">&nbsp;                setIP(server);</b>
&nbsp;
<b class="nc">&nbsp;                boolean isSocket = getView().askSocket();</b>
<b class="nc">&nbsp;                setController(server, isSocket);</b>
<b class="nc">&nbsp;                connection(isSocket);</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
&nbsp;
<b class="nc">&nbsp;                System.out.println(&quot;\033[31mConnection failed.\033[0m&quot;);</b>
&nbsp;                continue;
&nbsp;            }
&nbsp;
&nbsp;            try {
&nbsp;                while (true) {
&nbsp;
<b class="nc">&nbsp;                    currentStateMessage current = getController().getCurrent();</b>
<b class="nc">&nbsp;                    String state = current.getStateName();</b>
&nbsp;
<b class="nc">&nbsp;                    switch (state) {</b>
&nbsp;                        case &quot;serverOptionState&quot;: {
<b class="nc">&nbsp;                            serverOptions();</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;                        case &quot;connectionState&quot;: {
<b class="nc">&nbsp;                            name();</b>
<b class="nc">&nbsp;                            color();</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;                        case &quot;WaitingForPlayerState&quot;: {
<b class="nc">&nbsp;                            waitingPlayer(current);</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;                        case &quot;StarterCardState&quot;: {
<b class="nc">&nbsp;                            getView().updatePlayer(current);</b>
<b class="nc">&nbsp;                            if (Objects.equals(current.getCurrentPlayer().getNickname(), current.getPlayer().getNickname()))</b>
<b class="nc">&nbsp;                                starter();</b>
<b class="nc">&nbsp;                            updatePlayerMessage update = getController().updatePlayer();</b>
<b class="nc">&nbsp;                            getView().update(update);</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;                        case &quot;objectiveState&quot;: {
<b class="nc">&nbsp;                            getView().updatePlayer(current);</b>
<b class="nc">&nbsp;                            if (Objects.equals(current.getCurrentPlayer().getNickname(), current.getPlayer().getNickname()))</b>
<b class="nc">&nbsp;                                pickObjective();</b>
<b class="nc">&nbsp;                            updatePlayerMessage update = getController().updatePlayer();</b>
<b class="nc">&nbsp;                            getView().update(update);</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;                        case &quot;PlaceTurnState&quot;: {
<b class="nc">&nbsp;                            getView().updatePlayer(current);</b>
<b class="nc">&nbsp;                            if (Objects.equals(current.getCurrentPlayer().getNickname(), current.getPlayer().getNickname()))</b>
<b class="nc">&nbsp;                                placeCard();</b>
<b class="nc">&nbsp;                            updatePlayerMessage update = getController().updatePlayer();</b>
<b class="nc">&nbsp;                            getView().update(update);</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;                        case &quot;PickTurnState&quot;: {
<b class="nc">&nbsp;                            getView().updatePlayer(current);</b>
<b class="nc">&nbsp;                            if (Objects.equals(current.getCurrentPlayer().getNickname(), current.getPlayer().getNickname()))</b>
<b class="nc">&nbsp;                                pickCard();</b>
<b class="nc">&nbsp;                            updatePlayerMessage update = getController().updatePlayer();</b>
<b class="nc">&nbsp;                            getView().update(update);</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;                        case &quot;endGameState&quot;: {
<b class="nc">&nbsp;                            declareWinnerMessage end = getController().endGame();</b>
<b class="nc">&nbsp;                            getView().endGame(end);</b>
<b class="nc">&nbsp;                            throw new Exception(&quot;Game ended.&quot;);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        case &quot;ConnectionFAState&quot;: {
<b class="nc">&nbsp;                            pickNameFA();</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;
&nbsp;                        case &quot;AnswerCheckConnection&quot;: {
<b class="nc">&nbsp;                            getController().sendAnswerToPing();</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                getView().playerDisconnected(e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;}
&nbsp;
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-06-26 22:00</div>
</div>
</body>
</html>
